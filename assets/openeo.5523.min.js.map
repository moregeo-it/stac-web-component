{"version":3,"file":"openeo.5523.min.js","mappings":"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","sources":["webpack://vue-lib-openeo/./components/ModelBuilder.vue?57a5","webpack://vue-lib-openeo/./components/ModelBuilder.vue?ae06","webpack://vue-lib-openeo/./components/ModelBuilder.vue","webpack://vue-lib-openeo/components/ModelBuilder.vue","webpack://vue-lib-openeo/./components/ModelBuilder.vue?f2b7","webpack://vue-lib-openeo/./components/ModelBuilder.vue?b327"],"sourcesContent":["// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../node_modules/css-loader/dist/cjs.js??clonedRuleSet-64.use[1]!../node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-64.use[2]!../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-64.use[3]!../node_modules/sass-loader/dist/cjs.js??clonedRuleSet-64.use[4]!../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./ModelBuilder.vue?vue&type=style&index=0&id=cfd84820&prod&lang=scss\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add CSS to Shadow Root\nvar add = require(\"!../node_modules/vue-style-loader/lib/addStylesShadow.js\").default\nmodule.exports.__inject__ = function (shadowRoot) {\n  add(\"e7e49d04\", content, shadowRoot)\n};","// Imports\nimport ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ from \"../node_modules/css-loader/dist/runtime/noSourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.vue-component.model-builder{width:100%;height:100%;position:relative}.vue-component.model-builder.editable.focus .blocks{border-color:#1666b64d}.vue-component.model-builder .blocks:focus,.vue-component.model-builder .canvas:focus,.vue-component.model-builder:focus{outline:0}.vue-component.model-builder .canvas{width:100%;height:100%;position:absolute;z-index:1}.vue-component.model-builder .blocks{box-sizing:border-box;border:1px solid #0000;overflow:hidden;position:absolute;z-index:3;width:100%;height:100%}.vue-component.model-builder.compact .blockId,.vue-component.model-builder.compact .blockicon .addDescription,.vue-component.model-builder.compact .blockicon .delete,.vue-component.model-builder.compact .blockicon .info,.vue-component.model-builder.compact .editDescription,.vue-component.model-builder.scale_s .blockicon,.vue-component.model-builder.scale_xs .blockicon,.vue-component.model-builder.scale_xs .connector .text{display:none}.vue-component.model-builder .zoomInfo{position:absolute;top:0;right:0;display:inline-block;padding:.3em;background-color:#f9f9f9;color:#000;border-radius:0 0 0 .3em;z-index:5}.vue-component.model-builder.scale_xs .editDescription{visibility:hidden}`, \"\"]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',{ref:\"div\",class:_vm.classes,style:(_vm.style),attrs:{\"id\":_vm.id,\"tabindex\":\"0\"},on:{\"mousemove\":_vm.onMouseMove,\"mousedown\":_vm.onMouseDown,\"wheel\":_vm.onMouseWheel,\"keydown\":_vm.onKeyDown,\"focus\":function($event){_vm.hasFocus = true},\"blur\":function($event){_vm.hasFocus = false}}},[_c('svg',{staticClass:\"canvas\",attrs:{\"xmlns\":\"http://www.w3.org/2000/svg\",\"version\":\"1.1\"}},[_vm._l((_vm.edges),function(edge){return _c('Edge',{key:edge.id,attrs:{\"id\":edge.id,\"parameter1\":edge.parameter1,\"parameter2\":edge.parameter2,\"selected\":edge.selected,\"inactive\":edge.inactive,\"issues\":edge.issues,\"state\":_vm.state},on:{\"mounted\":node => _vm.mount(edge, node),\"unmounted\":() => _vm.mount(edge),\"position\":function($event){return _vm.updateEdgePos(edge, arguments)}}})}),_vm._l((_vm.hiddenParameterRefEdges),function(edge){return _c('Edge',{key:edge.id,attrs:{\"id\":edge.id,\"parameter1\":edge.parameter1,\"parameter2\":edge.parameter2,\"inactive\":true,\"lineColor\":[200,200,200,1],\"lineWidth\":2,\"state\":_vm.state},on:{\"mounted\":node => _vm.mount(edge, node),\"unmounted\":() => _vm.mount(edge)}})}),(_vm.linkingLine)?_c('line',_vm._b({},'line',_vm.linkingLine,false)):_vm._e(),(_vm.selectRect)?_c('rect',_vm._b({},'rect',_vm.selectRect,false)):_vm._e()],2),_c('div',{staticClass:\"blocks\"},_vm._l((_vm.blocks),function(block){return _c('Block',{key:block.id,attrs:{\"id\":block.id,\"type\":block.type,\"spec\":block.spec,\"state\":_vm.state,\"selected\":block.selected,\"position\":block.position,\"origin\":block.origin,\"process_id\":block.process_id,\"namespace\":block.namespace,\"result\":block.result,\"args\":block.arguments,\"description\":block.description},on:{\"update\":(...args) => _vm.updateBlock(block, ...args),\"mounted\":node => _vm.mount(block, node),\"unmounted\":() => _vm.mount(block),\"move\":_vm.startDragBlock}})}),1),(_vm.state.scale < 0.7 || _vm.showZoomInfo)?_c('div',{staticClass:\"zoomInfo\"},[(_vm.state.scale < 0.7)?_c('div',[_vm._v(\" Zoom in for more details. \")]):_vm._e(),(_vm.showZoomInfo)?_c('div',[_vm._v(\" Zoom with \"),_c('kbd',[_vm._v(\"STRG\")]),_vm._v(\" or \"),_c('kbd',[_vm._v(\"Meta\")]),_vm._v(\" key and the mouse wheel. \")]):_vm._e()]):_vm._e(),(_vm.parameterViewer)?_c('ParameterViewer',_vm._b({on:{\"close\":function($event){_vm.parameterViewer = null}}},'ParameterViewer',_vm.parameterViewer,false)):_vm._e()],1)\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n    <div ref=\"div\" :id=\"id\" :class=\"classes\" tabindex=\"0\" :style=\"style\"\n        @mousemove=\"onMouseMove\"\n        @mousedown=\"onMouseDown\"\n        @wheel=\"onMouseWheel\"\n        @keydown=\"onKeyDown\"\n        @focus=\"hasFocus = true\"\n        @blur=\"hasFocus = false\">\n        <!-- tabindex is to allow focus for delete keystroke etc -->\n        <svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" class=\"canvas\">\n            <Edge v-for=\"edge in edges\" :key=\"edge.id\" :id=\"edge.id\"\n                :parameter1=\"edge.parameter1\" :parameter2=\"edge.parameter2\"\n                :selected=\"edge.selected\" :inactive=\"edge.inactive\" :issues=\"edge.issues\" :state=\"state\"\n                @mounted=\"node => mount(edge, node)\" @unmounted=\"() => mount(edge)\"\n                @position=\"updateEdgePos(edge, arguments)\" />\n            <Edge v-for=\"edge in hiddenParameterRefEdges\" :key=\"edge.id\" :id=\"edge.id\"\n                :parameter1=\"edge.parameter1\" :parameter2=\"edge.parameter2\"\n                @mounted=\"node => mount(edge, node)\" @unmounted=\"() => mount(edge)\"\n                :inactive=\"true\" :lineColor=\"[200,200,200,1]\" :lineWidth=\"2\" :state=\"state\" />\n            <line v-if=\"linkingLine\" v-bind=\"linkingLine\" />\n            <rect v-if=\"selectRect\" v-bind=\"selectRect\" />\n        </svg>\n        <div class=\"blocks\">\n            <Block v-for=\"(block) in blocks\" :key=\"block.id\"\n                :id=\"block.id\" :type=\"block.type\" :spec=\"block.spec\" :state=\"state\"\n                :selected=\"block.selected\" :position=\"block.position\" :origin=\"block.origin\"\n                :process_id=\"block.process_id\" :namespace=\"block.namespace\" :result=\"block.result\" :args=\"block.arguments\" :description=\"block.description\" \n                @update=\"(...args) => updateBlock(block, ...args)\"\n                @mounted=\"node => mount(block, node)\" @unmounted=\"() => mount(block)\"\n                @move=\"startDragBlock\" />\n        </div>\n        <div v-if=\"state.scale < 0.7 || showZoomInfo\" class=\"zoomInfo\">\n            <div v-if=\"state.scale < 0.7\">\n                Zoom in for more details.\n            </div>\n            <div v-if=\"showZoomInfo\">\n                Zoom with <kbd>STRG</kbd> or <kbd>Meta</kbd> key and the mouse wheel.\n            </div>\n        </div>\n        <ParameterViewer v-if=\"parameterViewer\" v-bind=\"parameterViewer\" @close=\"parameterViewer = null\" />\n    </div>\n</template>\n\n<script>\nimport Block from './model-builder/Block.vue';\nimport Edge from './model-builder/Edge.vue';\nimport Utils from '../utils.js';\nimport { ProcessRegistry } from '@openeo/js-commons';\nimport { JsonSchemaValidator, ProcessGraph, Utils as PgUtils } from '@openeo/js-processgraphs';\nimport Vue from 'vue';\nimport boxIntersectsBox from 'intersects/box-box';\nimport boxIntersectsLine from 'intersects/box-line';\nimport Config from './model-builder/config.js';\n\nconst getDefaultState = function(blocks) {\n    return Vue.observable({\n        root: blocks,\n        editable: false,\n        compactMode: false,\n        moving: null, // Is the user dragging the view?\n        selecting: null, // Is the user multi-selecting?\n        center: [0,0],\n        mouse: [0,0],\n        scale: Config.defaultScale,\n        linkFrom: null, // Array\n        linkTo: null // Array\n    });\n};\nconst MARGIN = 20;\n\nconst selectionChangeWatcher = function (newVal, oldVal) {\n    if (!Array.isArray(newVal) || !Array.isArray(oldVal) || newVal.length !== oldVal.length || !newVal.every((value,i) => value.id === oldVal[i].id)) {\n        this.$emit('selectionChanged', this.selectedBlocks, this.selectedEdges);\n    }\n};\n\nexport default {\n    name: 'ModelBuilder',\n    components: {\n        Block,\n        Edge,\n        ParameterViewer: () => import('./model-builder/ParameterViewer.vue')\n    },\n    props: {\n        id: {\n            type: String,\n            required: true\n        },\n        editable: {\n            type: Boolean,\n            default: false\n        },\n        value: {\n            type: Object,\n            default: () => ({})\n        },\n        collections: {\n            type: Array,\n            default: () => []\n        },\n        processes: {\n            type: [Array, Object],\n            default: () => []\n        },\n\t\tparent: {\n\t\t\ttype: Object,\n\t\t\tdefault: null\n\t\t},\n\t\tparentSchema: {\n\t\t\ttype: Object,\n\t\t\tdefault: null\n\t\t},\n        historySize: {\n            type: Number,\n            default: 30\n        },\n        explicitZoom: {\n            type: Boolean,\n            default: false\n        },\n        height: {\n            type: String,\n            default: null\n        }\n    },\n    data() {\n        return {\n            isMounted: false,\n            allMounted: false,\n\n            // Current offset for block that are generated without specific coordinates so that not all block occur on the same position\n            newBlockOffset: 0,\n\n            // History\n            history: [],\n            historyPointer: null,\n\n            process: Object.freeze(this.value),\n            // Metadata for blocks to show\n            blocks: [],\n            // Metadata for edges to show\n            edges: [],\n            hiddenParameterRefEdges: {},\n\n            processGraph: null,\n\n            // Next block id\n            nextBlockId: 1,\n            // Next edge id\n            nextEdgeId: 1,\n            // Copy&Paste\n            clipboard: null,\n\n            activeTransactions: 0,\n            hasFocus: false,\n            linkingLine: null,\n            parameterViewer: null,\n\n            showZoomInfo: this.explicitZoom,\n            \n            // State specific to this blocks instance including all children\n            state: getDefaultState(this)\n        };\n    },\n    computed: {\n        style() {\n            let style = {};\n            if (typeof this.height === 'string') {\n                style.height = this.height;\n            }\n            return style;\n        },\n        classes() {\n            let classes = [\n                'vue-component',\n                'model-builder'\n            ];\n            if (this.hasFocus) {\n                classes.push('focus');\n            }\n            if (this.editable) {\n                classes.push('editable');\n            }\n\n            if (this.state.compactMode) {\n                classes.push('compact');\n            }\n\n            if (this.state.scale < 0.5) {\n                classes.push('scale_xs');\n            }\n            else if (this.state.scale < 0.7) {\n                classes.push('scale_s');\n            }\n            else if (this.state.scale < 0.9) {\n                classes.push('scale_m');\n            }\n            else if (this.state.scale < 1.1) {\n                classes.push('scale_l');\n            }\n            else {\n                classes.push('scale_xl');\n            }\n\n            return classes;\n        },\n        selectRect() {\n            if (!this.state.selecting) {\n                return null;\n            }\n            return {\n                x: Math.min(this.state.selecting.current[0], this.state.selecting.start[0]),\n                y: Math.min(this.state.selecting.current[1], this.state.selecting.start[1]),\n                width: Math.abs(this.state.selecting.current[0] - this.state.selecting.start[0]),\n                height: Math.abs(this.state.selecting.current[1] - this.state.selecting.start[1]),\n                'stroke': 'rgba(0,0,0,0.8)',\n                'stroke-width': 1,\n                'fill': 'rgba(0,0,0,0.05)'\n            };\n        },\n        processRegistry() {\n            // If I link between openeo-web-editor and openeo-vue-components, instanceof ProcessRegistry fails.\n            // Webpack seems to mangle names and thus I need to check for specific processes alternatively to detect whether this could be a ProcessRegistry.\n            if (this.processes instanceof ProcessRegistry || (typeof this.processes.count === 'function' && typeof this.processes.get === 'function')) {\n                return this.processes;\n            }\n            else if (Array.isArray(this.processes)) {\n                return new ProcessRegistry(this.processes);\n            }\n            else {\n                throw new Error('Invalid processes specified, must be ProcessRegistry or Array');\n            }\n        },\n        hasProcesses() {\n            return this.processRegistry.count() > 0;\n        },\n        processBlocks() {\n            return this.blocks.filter(b => b.type === 'process');\n        },\n        selectedBlocks() {\n            return this.blocks.filter(block => block.selected);\n        },\n        selectedEdges() {\n            return this.edges.filter(edge => edge.selected);\n        },\n        selectedSideEdge() {\n            if (this.selectedEdges.length === 1 && this.selectedEdges[0].selectedParameter) {\n                return this.selectedEdges[0];\n            }\n            return null;\n        },\n        hasSelection() {\n            return this.selectedBlocks.length > 0 || this.selectedEdges.length > 0;\n        },\n        processParametersFromSchemas() {\n            // Get all process parameters from the parent process\n            // this.parent.$parent => ModelBuilder instance\n\t\t\tlet parentParams = [];\n\t\t\tif (this.parent && this.parent.$parent && typeof this.parent.$parent.getPgParameters === 'function') {\n\t\t\t\tparentParams = this.parent.$parent.getPgParameters().map(block => block.spec);\n\t\t\t}\n\n            let callbackParams = [];\n            // If we have a parameter schema given, go through the parameter schema and get the available process parameters from there.\n            if (this.parentSchema) {\n\t\t\t    callbackParams = this.parentSchema.getCallbackParameters();\n            }\n\n            // Remove all parameters from the parent that are overridden by the more specific parameters.\n            let filteredParentParams = parentParams.filter(p1 => !callbackParams.find(p2 => p1.name === p2.name));\n            // Add the filtered parameters from the parent to the more specific parameters\n            return callbackParams.concat(filteredParentParams);\n        }\n    },\n    watch: {\n        parentSchema() {\n            this.importPgParameters(this.processParametersFromSchemas, 'schema');\n        },\n        async value(value) {\n            // Only run if component has been mounted\n            if (!this.allMounted) {\n                return;\n            }\n\n            // Only import when user changes data (i.e. not a BlocksProcess exported from export())\n            if (!(value instanceof BlocksProcess)) {\n                this.process = value;\n                await this.import(value, { propagate: false, undoOnError: false }); // don't propagate, otherwise results in an infinite loop\n            }\n        },\n        editable: {\n            immediate: true,\n            handler(editable) {\n                this.state.editable = editable;\n            }\n        },\n        selectedEdges: selectionChangeWatcher,\n        selectedBlocks: selectionChangeWatcher,\n        allMounted() {\n            this.updateHiddenParameterRefEdges();\n        },\n        isMounted() {\n            this.checkAllMounted();\n        }\n    },\n\tbeforeCreate() {\n\t\tUtils.enableHtmlProps(this);\n\t},\n    async created() {\n        if (!this.supports('error')) {\n            // Print error to console if event is not supported by implementing context\n            this.$on('error', (msg, title = null) => console.error(msg, title));\n        }\n        if (!this.supports('editArguments')) {\n            this.$on('editArguments', (...args) => this.showParameterViewer(...args));\n        }\n        this.$on('duplicate', this.duplicate.bind(this));\n    },\n    async mounted() {\n        Utils.loadFontAwesome(this);\n\n        // Setting up default viewer center\n        this.moveCenter(0, 0, true);\n\n        // ToDo: Replace with mouseleave?\n        this.onDocumentMouseUpFn = this.onDocumentMouseUp.bind(this)\n        document.addEventListener('mouseup', this.onDocumentMouseUpFn);\n\n        await this.importPgParameters(this.processParametersFromSchemas, 'schema');\n        if (!await this.import(this.value, { propagate: false, undoOnError: false })) {\n            this.perfectScale();\n        }\n        selectionChangeWatcher.bind(this)();\n\n        this.isMounted = true;\n    },\n    beforeDestroy() {\n        document.removeEventListener('mouseup', this.onDocumentMouseUpFn);\n    },\n    methods: {\n        updateEdgePos(edge, pos) {\n            edge.position1 = pos[0];\n            edge.position2 = pos[1];\n        },\n        mount(elem, node = null) {\n            elem.$el = node;\n            this.checkAllMounted();\n        },\n        checkAllMounted() {\n            if (!this.isMounted) {\n                this.allMounted = false;\n            }\n            else {\n                this.allMounted = !this.blocks.find(block => !block.$el) || !this.edges.find(edge => !edge.$el);\n            }\n        },\n        updateBlockArguments(block, args, removedParams) {\n            if (removedParams.length > 0) {\n                this.parameterRemoved(block, removedParams);\n            }\n            this.$set(block, 'arguments', args);\n            this.commit();\n            if(removedParams.length > 0) {\n                this.$nextTick(() => this.refreshEdges());\n            }\n        },\n        updateBlockDescription(block, description) {\n            this.$set(block, 'description', description);\n            this.commit();\n        },\n        updateBlockPos(block, pos, saveHistory = true) {\n            this.$set(block, 'position', pos);\n            this.commit(null, saveHistory, false);\n        },\n        updateBlockResult(block, result) {\n            this.$set(block, 'result', result);\n            this.commit();\n        },\n        updateBlockSelected(block, selected, unselectOthers = true) {\n            if (unselectOthers) {\n                this.unselectAll();\n            }\n            this.$set(block, 'selected', selected);\n            this.commit(null, false, false);\n        },\n        updateBlockSpec(block, data) {\n            let parameterFields = ['name', 'schema', 'description', 'optional', 'deprecated', 'experimental', 'default'];\n            let newBlock = Utils.omitFromObject(block.spec, parameterFields);\n            Object.assign(newBlock, data);\n            // Remove default values (and unset default value if parameter is required)\n            if (!newBlock.optional) {\n                delete newBlock.optional;\n                delete newBlock.default;\n            }\n            if (!newBlock.deprecated) {\n                delete newBlock.deprecated;\n            }\n            if (!newBlock.experimental) {\n                delete newBlock.experimental;\n            }\n            this.$set(block, 'spec', newBlock);\n            this.commit();\n        },\n        updateBlock(block, key, value, extra) {\n            switch(key) {\n                case 'arguments':\n                    this.updateBlockArguments(block, value, extra);\n                    break;\n                case 'description':\n                    this.updateBlockDescription(block, value);\n                    break;\n                case 'position':\n                    this.updateBlockPos(block, value, extra);\n                    break;\n                case 'result':\n                    this.setResultNode(block, value);\n                    break;\n                case 'selected':\n                    this.updateBlockSelected(block, value, extra);\n                    break;\n                case 'spec':\n                    this.updateBlockSpec(block, value);\n                    break;\n            }\n        },\n        updateHiddenParameterRefEdges() {\n            // We can only reliably detect parameter refs if we know which parameters a process makes available to the child process\n            // So if we don't have process schemas, don't offer this functionality.\n            // Also don't execute (yet) if no parameters are given or not all elements are mounted yet.\n            if (!this.hasProcesses || !this.allMounted || !this.blocks.find(block => block.type === 'parameter')) {\n                this.hiddenParameterRefEdges = {};\n                return;\n            }\n\n            let hiddenRefs = {};\n            for(let process of this.processBlocks) {\n                for (let argName in process.arguments) {\n                    let value = process.arguments[argName];\n                    if (!Utils.isObject(value) || !Utils.isObject(value.process_graph)) {\n                        continue; // Process can only have hidden refs it it contains a process graph\n                    }\n                    \n                    let refs = PgUtils.getRefs(value, true, true).filter(ref => typeof ref.from_parameter !== 'undefined');\n                    for(let ref of refs) {\n                        try {\n                            if(!process.$el) {\n                                continue;\n                            }\n                            if (process.$el.isParameterScoped(argName, ref.from_parameter)) {\n                                continue; // Skip if the parameter usage is scoped (i.e. defined as process parameetr for the children)\n                            }\n                            let parameter = this.getPgParameterById('$' + ref.from_parameter);\n                            if (!parameter) {\n                                continue; // Skip if parameter can't be found\n                            }\n                            let parameter1 = parameter.$el.getBlockParameter('output');\n                            let parameter2 = process.$el.getBlockParameter(argName);\n                            let id = `${parameter.id}->${process.id}:${argName}`;\n                            if (parameter1 && parameter2) {\n                                if (this.hiddenParameterRefEdges[id]) {\n                                    hiddenRefs[id] = this.hiddenParameterRefEdges[id];\n                                }\n                                else {\n                                    hiddenRefs[id] = {\n                                        $el: null,\n                                        id,\n                                        parameter1,\n                                        parameter2\n                                    };\n                                }\n                            }\n                        } catch(error) {\n                             console.warn(error);\n                        }\n                    }\n                }\n\n            }\n            this.hiddenParameterRefEdges = hiddenRefs;\n        },\n        parameterRemoved(block, parameterNames) {\n            for(let edge of this.edges.slice(0)) {\n                if(edge.parameter2.$parent.id === block.id && parameterNames.includes(edge.parameter2.name)) {\n                    this.removeEdge(edge);\n                }\n            }\n        },\n        startDragBlock(event) {\n            for(let block of this.blocks) {\n                if (block.$el) {\n                    block.$el.startDrag(event);\n                }\n            }\n        },\n        refreshEdges() {\n            this.refreshEdgesFor(this.edges);\n            this.refreshEdgesFor(Object.values(this.hiddenParameterRefEdges));\n        },\n        refreshEdgesFor(edges) {\n            for(let edge of edges) {\n                if (edge.$el) {\n                    edge.$el.updatePositions();\n                }\n            }\n        },\n        supports(event) {\n            return Boolean(this.$listeners && this.$listeners[event]);\n        },\n        focus() {\n            this.$refs.div.focus();\n        },\n        link(parameter) {\n            if (this.state.linkFrom) {\n                this.state.linkTo = parameter;\n            }\n            else {\n                this.state.linkFrom = parameter;\n            }\n        },\n        unlink(parameter = null) {\n            if (parameter) {\n                if (this.state.linkTo == parameter) {\n                    this.state.linkTo = null;\n                }\n                else if (this.state.linkFrom == parameter) {\n                    this.state.linkFrom = null;\n                    this.linkingLine = null;\n                }\n            }\n            else {\n                this.state.linkTo = null;\n                this.state.linkFrom = null;\n                this.linkingLine = null;\n            }\n        },\n        multiSelect() {\n            let box = this.selectRect;\n            this.blocks\n                .filter(b => {\n                    if (Array.isArray(b.position) && b.$el) {\n                        let pos = b.$el.getDimensions();\n                        return boxIntersectsBox(box.x, box.y, box.width, box.height, pos.x, pos.y, pos.width, pos.height);\n                    }\n                    return false;\n                })\n                .map(b => b.selected = true);\n            this.edges\n                .filter(e => Array.isArray(e.position1) && Array.isArray(e.position2) && boxIntersectsLine(box.x, box.y, box.width, box.height, e.position1[0], e.position1[1], e.position2[0], e.position2[1]))\n                .map(e => e.selected = true);\n        },\n        toJSON() {\n            let process = this.export();\n            return JSON.stringify(process, null, 2);\n        },\n        async onDocumentMouseUp(event) {\n            if (this.parameterViewer) {\n                return;\n            }\n            if (this.selectedSideEdge) {\n                this.selectEdge(this.selectedSideEdge, null); // Reset selectedParameter, but don't change selected state.\n            }\n            if (this.state.selecting) {\n                this.multiSelect();\n                this.state.selecting = null;\n            }\n            if (this.state.moving) {\n                this.state.moving = null;\n            }\n            if (this.state.editable && this.state.linkFrom) {\n                if (event.which == 1 && this.state.linkTo) {\n                    try {\n                        await this.addEdge(this.state.linkFrom, this.state.linkTo);\n                    } catch (error) {\n                        this.$emit(\"error\", error);\n                    }\n                }\n                this.unlink();\n            }\n        },\n        async onKeyDown(event) {\n            if (this.parameterViewer) {\n                return;\n            }\n            var allInputs = document.querySelectorAll('input, textarea, button, select, datalist');\n            for(let el of allInputs) {\n                if (el === document.activeElement) {\n                    return;\n                }\n            }\n\n            let captured = false;\n            if (this.state.editable) {\n                // delete selected blocks/edges\n                if (event.code === 'Delete') {\n                    this.deleteSelected();\n                    captured = true;\n                }\n                else if (event.ctrlKey || event.metaKey) { // STRG for Win/Linux, meta/cmd from Mac\n                    if (event.code === 'KeyV') {\n                        if (!navigator || !navigator.clipboard || typeof navigator.clipboard.readText !== 'function') {\n                            this.$emit('error', 'Pasting is not supported by your browser.');\n                            return;\n                        }\n                        if (this.hasSelection && this.clipboard) {\n                            if (this.clipboard.edges.length > 0) {\n                                this.$emit('error', 'Pasting edges is not supported yet.');\n                                return;\n                            }\n                            if (this.clipboard.blocks.length > 0) {\n                                this.clipboard.blocks.forEach(block => {\n                                    if (block.type === 'process' && block.origin !== 'schema') {\n                                        this.duplicate(Utils.pickFromObject(block, [\"arguments\", \"description\", \"namespace\", \"position\", \"process_id\"]));\n                                    }\n                                    else {\n                                        this.$emit('error', `Pasting block '${block.id}' is not supported.`);\n                                    }\n                                });\n                            }\n                        }\n                        else {\n                            try {\n                                const text = await navigator.clipboard.readText();\n                                let process = JSON.parse(text);\n                                await this.import(process);\n                            } catch(error) {\n                                this.$emit('error', error, 'Paste Error');\n                            }\n                        }\n                        captured = true;\n                    }\n                    else if (event.code === 'KeyC') {\n                        if (!navigator || !navigator.clipboard || typeof navigator.clipboard.writeText !== 'function') {\n                            this.$emit('error', 'Copying is not supported by your browser.');\n                            return;\n                        }\n                        if (this.hasSelection) {\n                            this.clipboard = {\n                                blocks: this.selectedBlocks.slice(0),\n                                edges: this.selectedEdges.slice(0)\n                            };\n                        }\n                        else {\n                            try {\n                                let json = this.toJSON();\n                                await navigator.clipboard.writeText(json);\n                                captured = true;\n                            } catch(error) {\n                                this.$emit('error', error, 'Copy Error');\n                            }\n                        }\n                        captured = true;\n                    }\n                }\n            }\n\n            if (captured) {\n                event.preventDefault();\n                event.stopPropagation();\n            }\n        },\n        onMouseWheel(event) {\n            if (this.parameterViewer) {\n                return;\n            }\n            if (!this.explicitZoom || this.hasFocus || event.ctrlKey || event.metaKey) { // STRG for Win/Linux, meta/cmd for Mac\n                let mouse = this.getMousePos(event);\n                var dX = mouse[0] - this.state.center[0];\n                var dY = mouse[1] - this.state.center[1];\n                var deltaScale = Math.pow(1.1, Math.sign(event.deltaY)*-1);\n                this.moveCenter(-dX*(deltaScale-1), -dY*(deltaScale-1));\n                this.state.scale *= deltaScale;\n                event.preventDefault();\n                this.showZoomInfo = false;\n            }\n        },\n        domBoundingBox(el) {\n            var rect = el.getBoundingClientRect();\n            rect.offsetTop = rect.top + Math.max(document.documentElement.scrollTop, document.body.scrollTop);\n            rect.offsetLeft = rect.left + Math.max(document.documentElement.scrollLeft, document.body.scrollLeft);\n            return rect;\n        },\n        getMousePos(event) {\n            let root = this.$refs.div.getBoundingClientRect();\n            return [\n                event.clientX - root.left,\n                event.clientY - root.top\n            ];\n        },\n        onMouseMove(event) {\n            if (this.parameterViewer) {\n                return;\n            }\n            try {\n                let mousePos = this.getMousePos(event);\n\n                if (this.state.editable && this.selectedSideEdge) {\n                    var origin = this.selectedSideEdge.selectedParameter.getCirclePosition();\n                    if (origin) {\n                        var distance = Math.sqrt(Math.pow(mousePos[0]-origin[0], 2)+Math.pow(mousePos[1]-origin[1], 2));\n                        if (distance > 10) {\n                            this.link(this.selectedSideEdge.selectedParameter);\n                            this.removeEdge(this.selectedSideEdge);\n                            this.commit();\n                        }\n                    }\n                }\n\n                if (this.state.selecting) {\n                    this.state.selecting.current = mousePos;\n                }\n\n                if (this.state.moving) {\n                    this.moveCenter((mousePos[0]-this.state.moving[0]), (mousePos[1]-this.state.moving[1]));\n                    this.state.moving = mousePos;\n                }\n\n                if (this.state.linkFrom) {\n                    var position = this.state.linkFrom.getCirclePosition();\n                    if (position) {\n                        this.linkingLine = {\n                            x1: position[0],\n                            y1: position[1],\n                            x2: mousePos[0],\n                            y2: mousePos[1],\n                            'stroke': 'rgba(0,0,0,0.4)',\n                            'stroke-width': 3 * this.state.scale\n                        };\n                    }\n                }\n            } catch (error) {\n                this.$emit(\"error\", error);\n            }\n        },\n        onMouseDown(event) {\n            if (this.parameterViewer) {\n                return;\n            }\n            let sideSelected = null;\n            let mousePos = this.getMousePos(event);\n\n            if (event.which == 1) {\n                if (event.shiftKey) {\n                    // Start multi select via box\n                    this.state.selecting = {\n                        start: mousePos,\n                        current: mousePos\n                    }\n                }\n                else {\n                    // No multiselect: unselect all\n                    this.unselectAll();\n                }\n\n                // Select edges\n                for (var edge of this.edges) {\n                    if (!edge.$el) {\n                        continue;\n                    }\n                    var collide = edge.$el.collide(mousePos[0], mousePos[1]);\n                    if (collide != false) {\n                        if (this.selectedEdges.length === 0 && !event.shiftKey) {\n                            if (collide < 0.3) {\n                                sideSelected = edge.parameter2;\n                            }\n                            else if (collide > 0.7) {\n                                sideSelected = edge.parameter1;\n                            }\n                        }\n                        this.selectEdge(edge, true, sideSelected);\n                        if (edge.issues.length > 0) {\n                            for(let issue of edge.issues) {\n                                this.$emit('error', issue);\n                            }\n                        }\n                        event.preventDefault();\n                        break;\n                    }\n                }\n            }\n\n            if (event.which == 2 || (event.which == 1 && !sideSelected && !event.shiftKey)) {\n                this.state.moving = mousePos;\n            }\n\n            this.focus();\n        },\n\n        getDimensions() {\n            return this.domBoundingBox(this.$refs.div);\n        },\n\n        async clear() {\n            return await this.startTransaction(async () => {\n                this.edges = [];\n                // Don't remove parameters injected by props (fixed callback parameters)\n                this.blocks = this.blocks.filter(b => b.type === 'parameter' && Utils.isObject(b.spec) && b.origin === 'schema');\n                this.nextBlockId = 1;\n                this.nextEdgeId = 1;\n                this.process = {};\n                this.updateHiddenParameterRefEdges();\n                return true;\n            });\n        },\n\n        commit(data = null, history = true, propagate = true) {\n            // Don't commit when in a transaction\n            if (this.activeTransactions > 0) {\n                return;\n            }\n\n            if (history !== false) {\n                this.saveHistory();\n            }\n            if (propagate !== false) {\n                this.$emit('input', data === null ? this.export() : data);\n                this.updateHiddenParameterRefEdges();\n            }\n            else {\n                this.refreshEdges();\n            }\n        },\n    \n        /**\n         * Save the current situation to the history\n         */\n        saveHistory() {\n            var data = this.export(true);\n            this.history.splice(this.historyPointer + 1, this.historySize, Object.freeze(data));\n            if (this.history.length > this.historySize) {\n                this.history.shift();\n            }\n            this.historyPointer = this.history.length - 1;\n            this.$emit('historyChanged', this.history, this.historyPointer);\n        },\n        async undo() {\n            await this.historyStep(-1);\n        },\n        async redo() {\n            await this.historyStep(1);\n        },\n        async historyStep(step) {\n            var index = this.historyPointer + step;\n            var element = this.history[index];\n            if (element) {\n                this.historyPointer = index;\n                this.import(element, { saveHistory: false, undoOnError: false, perfectScale: false });\n                this.$emit('historyChanged', this.history, this.historyPointer);\n            }\n        },\n\n        setResultNode(block, result = true) {\n            block = this.getBlockById(block.id);\n            if (!block || block.result === result) {\n                return; // Nothing to change\n            }\n\n            this.updateBlockResult(block, result);\n            var foundNewResultNode = false;\n            var hasOtherBlocks = false;\n            for(var other of this.processBlocks) {\n                if (block && other.id === block.id) {\n                    continue;\n                }\n                \n                hasOtherBlocks = true;\n                // If we set a new result node, ensure that only that node is a result node and no other.\n                if (result) {\n                    this.updateBlockResult(other, false);\n                }\n                // Find a potential result node if we don't want this to be the result node\n                else {\n                    if (other.$el && !other.$el.hasOutputEdges()) {\n                        this.updateBlockResult(other, true);\n                        foundNewResultNode = true;\n                        break;\n                    }\n                }\n            }\n            // If we have no new potential result node, communicate to the user.\n            if (hasOtherBlocks && !result && !foundNewResultNode) {\n                this.$emit(\"error\", \"No result node available, please specify one.\");\n            }\n        },\n\n        getPositionForPageXY(x, y) {\n            var rect = this.getDimensions();\n            if (x !== null) {\n                x = (x - rect.offsetLeft - this.state.center[0]) / this.state.scale;\n            }\n            if (y !== null) {\n                y = (y - rect.offsetTop - this.state.center[1]) / this.state.scale;\n            }\n            return [x, y];\n        },\n\n        duplicate(data) {\n            data = Utils.deepClone(data);\n            if (data.position) {\n                data.position[1] += 100;\n            }\n            let block = this.addBlock(data);\n            this.$nextTick(() => this.createEdgesForArguments(block.id, data.arguments));\n        },\n\n        addProcess(process_id, args = {}, position = [], namespace = null) {\n            return this.addBlock({\n                process_id,\n                namespace,\n                arguments: args,\n                position\n            });\n        },\n\n        addBlock(node, id = null) {\n            let num = String(this.incrementId(id));\n            if (id === null && Utils.hasText(node.process_id)) {\n                id = node.process_id.replace(/^([a-z]*).*$/i, \"$1\") + num;\n                if (this.getBlockById('#' + id)) {\n                    id = num;\n                }\n            }\n            else {\n                id = num;\n            }\n            if (typeof node.toJSON === 'function') {\n                node = node.toJSON();\n            }\n            var block = {\n                id: '#' + id,\n                type: 'process',\n                selected: false,\n                position: node.position,\n                process_id: node.process_id,\n                namespace: node.namespace,\n                arguments: node.arguments,\n                description: node.description || null,\n                result: node.result || false\n            };\n            if (this.processRegistry) {\n                block.spec = this.processRegistry.get(node.process_id, node.namespace);\n            }\n\n            var size = this.getBlockSize(block);\n            block.position = Utils.ensurePoint(block.position, () => this.getNewBlockDefaultPosition(size));\n\n            // If there's already a result node, remove the flag here\n            if (block.result && this.blocks.filter(b => b.result === true).length) {\n                delete block.result;\n            }\n            // Make this the result node if there's no node yet\n            else if (this.processBlocks.length === 0) {\n                block.result = true;\n            }\n            \n            this.blocks.push(Vue.observable(block));\n            this.commit();\n            return block;\n        },\n\n        getNewBlockDefaultPosition(blockSize) {\n            var rect = this.getDimensions();\n            var position = [\n                (-this.state.center[0] + rect.width/2)/this.state.scale - blockSize[0]/2 + this.newBlockOffset,\n                (-this.state.center[1] + rect.height/2)/this.state.scale - blockSize[1]/2 + this.newBlockOffset\n            ];\n            if (this.newBlockOffset < 150) {\n                this.newBlockOffset += 10;\n            }\n            return position;\n        },\n\n        getBlockSize(block) {\n            if (block.$el) {\n                let dim = block.$el.getDimensions();\n                return [dim.width / this.state.scale, dim.height / this.state.scale];\n            }\n\n            let inputs = Math.max(\n                Utils.size(block.arguments),\n                Utils.isObject(block.spec) ? Utils.size(block.spec.parameters) : 0\n            );\n\n            let size = Config.blockWidth;\n            let width;\n            if (inputs > 0) {\n                width = this.state.compactMode ? size.compactParams : size.normalParams;\n            }\n            else {\n                width = this.state.compactMode ? size.compact : size.normal;\n            }\n\n            let commentHeight = typeof block.description === 'string' ? 40 : 0;\n            let height = MARGIN + inputs * 15 + commentHeight;\n\n            return [width, height];\n        },\n\n        moveCenter(dX, dY, reset = false) {\n            var rect = this.getDimensions();\n            this.state.center = [\n                (reset ? rect.width/2 : this.state.center[0]) + dX,\n                (reset ? rect.height/2 : this.state.center[1]) + dY\n            ];\n            this.newBlockOffset = 0;\n        },\n\n        unselectAll() {\n            for(var block of this.blocks) {\n                this.updateBlockSelected(block, false, false);\n            }\n            for(var edge of this.edges) {\n                this.selectEdge(edge, false);\n            }\n        },\n\n        selectEdge(edge, select = true, parameter = null) {\n            if (!Utils.isObject(edge)) {\n                edge = this.edges[edge];\n            }\n            if (edge.selected === select) {\n                return false; // Nothing to change\n            }\n            if (select !== null) {\n                this.$set(edge, \"selected\", select);\n            }\n            this.$set(edge, \"selectedParameter\", parameter);\n            return true;\n        },\n\n        /**\n         * Edge to remove\n         */\n        removeEdge(edge) {\n            edge.parameter1.eraseEdge(edge);\n            edge.parameter2.eraseEdge(edge);\n            this.$delete(this.edges, this.edges.indexOf(edge));\n        },\n            \n        /**\n         * Remove a block\n         */\n        async removeBlock(block) {\n            // Check if the parameter for this block is used in child processes (callbacks).\n            // Then don't delete, but give error instead.\n            if (block.type === 'parameter') {\n                let param = null;\n                let conflictBlock = this.blocks.find(otherBlock => {\n                    param = otherBlock.$el.hiddenParameterRef(block);\n                    return (param !== null);\n                });\n                if (conflictBlock) {\n                    throw new Error(`Parameter is still used in '${conflictBlock.id}', parameter '${param}'. Only unused parameters can be deleted.`);\n                }\n            }\n\n            // now start deleting the block\n            return await this.startTransaction(async () => {\n                var i = this.blocks.findIndex(b => b.id == block.id);\n                if (i < 0) {\n                    return false;\n                }\n\n                for (var edge of this.edges.slice(0)) {\n                    if (edge.parameter1.$parent.id === block.id || edge.parameter2.$parent.id === block.id) {\n                        this.removeEdge(edge);\n                    }\n                }\n\n                if (block.result) {\n                    this.setResultNode(block, false);\n                }\n\n                this.$delete(this.blocks, i);\n                return true;\n            });\n        },\n\n        /**\n         * Retreive a block by ID\n         */\n        getBlockById(blockId) {\n            var blocks = this.blocks.filter(block => block.id === blockId);\n            if (blocks.length > 0) {\n                return blocks[0];\n            }\n            return null;\n        },\n\n        /**\n         * Delete the current link\n         */\n        async deleteSelected() {\n            if (!this.hasSelection) {\n                return false;\n            }\n\n            return await this.startTransaction(async () => {\n                // Remove the selected blocks and its edges\n                for(var block of this.selectedBlocks.slice(0)) { // copy to avoid race condition\n                    if (block.$el.allowsDelete) {\n                        await this.removeBlock(block);\n                    }\n                }\n\n                // Removes the selected edges\n                for(var edge of this.selectedEdges.slice(0)) { // copy to avoid race condition\n                    this.removeEdge(edge);\n                }\n                return true;\n            });\n        },\n\n        async addEdgeByNames(b1, p1, b2, p2) {\n            var blocks = [];\n            for(var id of [b1, b2]) {\n                var block = this.getBlockById(id);\n                if (!block) {\n                    throw \"Can't find block: \" + id;\n                }\n                else if (!block.$el) {\n                    throw \"Block not mounted yet: \" + id;\n                }\n                blocks.push(block.$el);\n            }\n            await this.addEdge(\n                blocks[0].getBlockParameter(p1),\n                blocks[1].getBlockParameter(p2)\n            );\n        },\n \n        async addEdge(p1, p2) {\n            if (!p1 || !p2) {\n                throw 'One of the parameters is invalid.';\n            }\n            // Check whether you want to connect the same parameters\n            if (p1 == p2) {\n                return; // Probably by mistake, don't show an error to not annoy people\n            }\n            // Check whether you want to connect the block to itself\n            if (p1.$parent == p2.$parent) {\n                throw 'You can\\'t link a block to itself';\n            }\n\n            var id = this.nextEdgeId++;\n            var edge = {id, selected: false, inactive: false, issues: [], $el: null};\n            if (p1.output) {\n                edge.parameter1 = p1;\n                edge.parameter2 = p2;\n            }\n            else {\n                // Reverse the order of in and out\n                edge.parameter1 = p2;\n                edge.parameter2 = p1;\n            }\n\n            // You have to link an input with an output\n            if (edge.parameter1.output === edge.parameter2.output) {\n                throw 'You have to link an input with an output';\n            }\n            // Check for non-recursiveness\n            if (this.allSuccessors(edge.parameter1).indexOf(edge.parameter2.id) !== -1) {\n                throw 'You can not create a loop';\n            }\n            // Check whether the data type allows multiple input edges\n            if (edge.parameter2.getEdgeCount() > 0 && !edge.parameter2.allowsMultipleInputs) {\n                throw 'Parameter accepts only one input';\n            }\n\n            // Check whether the edge exists\n            for (var other of this.edges) {\n                if (other.$el && other.$el.equals(edge)) {\n                    throw 'This connection exists already';\n                }\n            }\n\n            // Check type compatibility\n            if (!JsonSchemaValidator.isSchemaCompatible(edge.parameter2.schema || {}, edge.parameter1.schema || {}, false, true)) {\n                let issue = 'Incoming data type is not compatible for parameter \"' + edge.parameter2.name + '\"';\n                edge.issues.push(issue);\n                this.$emit('error', issue);\n            }\n\n            return await this.startTransaction(async () => {\n                this.unlink();\n\n                // Create edge\n                this.edges.push(Vue.observable(edge));\n                edge.parameter1.addEdge(edge);\n                edge.parameter2.addEdge(edge);\n\n                // Update result node\n                this.setResultNode(edge.parameter1.$parent, false);\n                return true;\n            });\n        },\n\n        /**\n         * Find all successors of a block, and their successors\n         */\n        allSuccessors(outputParameter) {\n            var block = outputParameter.$parent;\n            // Blocks already explored\n            var explored = {};\n            var exploreList = [block];\n            explored[block.id] = true;\n        \n            while (exploreList.length > 0) {\n                var currentBlock = exploreList.pop();\n                for (var key in currentBlock.edges) {\n                    for (var i in currentBlock.edges[key]) {\n                        var edge = currentBlock.edges[key][i];\n                        if (edge.block1 == currentBlock) {\n                            var target = edge.block2;\n                            if (!(target.id in explored)) {\n                                explored[target.id] = true;\n                                exploreList.push(target);\n                            }\n                        }\n                    }\n                }\n            }\n\n            return Object.values(explored);\n        },\n\n        /**\n         * Changing the compact mode\n         */\n        async toggleCompact() {\n            this.state.compactMode = !this.state.compactMode;\n            this.$emit('compactMode', this.state.compactMode);\n            await this.$nextTick();\n            this.refreshEdges();\n        },\n\n        export(internal = false) {\n            let data = {\n                process_graph: {}\n            };\n\n            for(let block of this.processBlocks) {\n                let keys = ['process_id', 'namespace', 'arguments', 'description', 'result'];\n                if (internal) {\n                    // Keep internal state for history\n                    keys.push('position');\n                }\n                let copy = Utils.pickFromObject(block, keys);\n                // Remove default values for simplicity\n                if (copy.description === null) {\n                    delete copy.description;\n                }\n                if (copy.result !== true) {\n                    delete copy.result;\n                }\n                if (!copy.namespace) {\n                    delete copy.namespace;\n                }\n                let nodeId = block.id.substr(1);\n                data.process_graph[nodeId] = copy;\n            }\n\n            if (!this.parent) {\n                data.parameters = [];\n                let parameterBlocks = this.getPgParameters();\n                for(let param of parameterBlocks) {\n                    data.parameters.push(param.spec);\n                }\n            }\n\n            // ToDo: Currently, we just use the id, categories, result value etc from the original process.\n            // Implement to allow custom settings from users.\n            return new BlocksProcess(Object.assign({}, this.process, data));\n        },\n\n        // Options may contain:\n        // - undoOnError: don't undo changes when an error occured (default: true)\n        // - saveHistory: commit the changes to the history (default: true)\n        // - propagate: emit the changes to the parent v-model (default: true)\n        async startTransaction(fn, options = {}, ...args) {\n            let success;\n            this.activeTransactions++;\n\n            try {\n                success = await fn(args);\n            } catch (error) {\n                // If an error occured: show it and restore the last working state from history.\n                this.$emit('error', error, \"Model is invalid\");\n                if (options.undoOnError !== false) {\n                    try {\n                        await this.undo();\n                    } catch (error2) {\n                        this.$emit('error', error, \"Revert failed\");\n                    }\n                }\n                success = false;\n            }\n\n            this.activeTransactions--;\n            this.commit(null, options.saveHistory, options.propagate);\n\n            return success;\n        },\n\n        // Options may contain:\n        // - all from startTransaction()\n        // - clear: Clear the model builder before import (default: true)\n        // - perfectScale: Apply perfect scale after import (default: true)\n        async import(process, options = {}) {\n            return await this.startTransaction(async () => {\n                // clear screen...\n                if (options.clear !== false) {\n                    await this.clear();\n                    this.process = process instanceof ProcessGraph ? process.toJSON() : process;\n                }\n\n                if (!Utils.isObject(process)) {\n                    return false;\n                }\n\n                // Parse process\n                let pg;\n                if (process instanceof ProcessGraph) {\n                    // Make a copy\n                    pg = new ProcessGraph(process.toJSON(), this.processRegistry);\n                    pg.setParent(process.parentProcessId, process.parentParameterName);\n                }\n                else {\n                    pg = new ProcessGraph(process, this.processRegistry);\n                }\n                pg.allowEmpty();\n                pg.parse();\n                this.processGraph = Object.freeze(pg);\n\n                await this.importPgParameters(this.processGraph.getProcessParameters(true), 'user', options.clear !== false);\n                await this.importNodes(this.processGraph.getStartNodes());\n                await this.importEdges(this.processGraph);\n\n                if (options.perfectScale !== false) {\n                    this.perfectScale();\n                }\n\n                this.$nextTick(() => this.updateHiddenParameterRefEdges());\n\n                return true;\n            }, options);\n        },\n\n        async importPgParameters(params, origin, clear = true) {\n            if (!Array.isArray(params)) {\n                return;\n            }\n\n            let options = {\n                undoOnError: false,\n                saveHistory: false,\n                propagate: false\n            };\n            return await this.startTransaction(async () => {\n                // Remove existing parameters from the given origin\n                if (clear) {\n                    this.blocks = this.blocks.filter(b => b.type !== 'parameter' || b.origin !== origin);\n                }\n\n                let size = this.getBlockSize({}); // Estimate base size for an empty block\n                let position = [0,0];\n                for(var i in params) {\n                    position = [\n                        -size[0] - MARGIN,\n                        i * (size[1] + MARGIN)\n                    ];\n\n                    await this.addPgParameter(params[i], origin, position);\n                }\n            }, options);\n        },\n\n        async addPgParameter(param, origin = 'user', position = null) {\n            return await this.startTransaction(async () => {\n                let id = '$' + param.name;\n                // Check a parameter with the same name exists\n                if (this.blocks.findIndex(p => p.type === 'parameter' && p.id == id) >= 0) {\n                    return false;\n                }\n                param = Utils.deepClone(param);\n                if (typeof param.schema === 'undefined') {\n                    param.schema = {};\n                }\n                this.blocks.push(Vue.observable({\n                    id,\n                    type: 'parameter',\n                    origin,\n                    position: Utils.ensurePoint(position, () => this.getNewBlockDefaultPosition(this.getBlockSize({}))),\n                    spec: Object.freeze(param)\n                }));\n                return true;\n            });\n        },\n\n        getPgParameters() {\n            return this.blocks.filter(b => b.type === 'parameter');\n        },\n\n        getPgParameterById(id) {\n            return this.blocks.find(b => b.type === 'parameter' && b.id === id);\n        },\n\n        async importEdges(pg) {\n            var nodes = pg.getNodes();\n            return Promise.all(Object.values(nodes).map(node => this.importEdgesForNode(node)));\n        },\n\n        async importEdgesForNode(node) {\n            var args = node.getArgumentNames();\n            for(let i in args) {\n                let arg = args[i];\n                let val = node.getRawArgument(arg);\n                let ref = '#' + node.id;\n                switch(node.getArgumentType(arg)) {\n                    case 'result':\n                        await this.addEdgeByNames('#' + val.from_node, \"output\", ref, arg, false);\n                        break;\n                    case 'parameter':\n                        await this.addEdgeByNames('$' + val.from_parameter, \"output\", ref, arg, false);\n                        break;\n                    case 'object':\n                    case 'array':\n                        await this.importEdgeDeep(val, ref, arg);\n                        break;\n                }\n            }\n        },\n\n        async importEdgeDeep(val, nodeId, arg) {\n            for(let k in val) {\n                // k !== 'process_graph' prevents importing sub process graphs like in load_collection, see #118\n                if(val[k] && typeof val[k] === \"object\" && k !== 'process_graph') {\n                    await this.importEdgeDeep(val[k], nodeId, arg);\n                }\n                else if (!Utils.isRef(val)) {\n                    continue;\n                }\n                else if (val.from_node) {\n                    await this.addEdgeByNames('#' + val.from_node, \"output\", nodeId, arg, false);\n                }\n                else if (val.from_parameter) {\n                    await this.addEdgeByNames('$' + val.from_parameter, \"output\", nodeId, arg, false);\n                }\n            }\n        },\n\n        async createEdgesForArguments(nodeId, args) {\n            for(let arg in args) {\n                await this.importEdgeDeep(args[arg], nodeId, arg);\n            }\n        },\n\n        async importNodes(nodes, x = 0, y = 0, imported = []) {\n            let nextNodes = [];\n            let maxX = 0;\n            for(let node of nodes) {\n                // `node` is a Node class instance as defined by the js-processgraphs library\n                // `data` is the simple object that is defined by JSON process graphs\n                // `block` is the representation used by the Block component to render the block\n\n                // To get a better layout, only add the block once all previous nodes are added\n                if (imported.includes(node.id) || node.getPreviousNodes().find(prev => !imported.includes(prev.id)) !== undefined) {\n                    y += MARGIN / 2; // add a small offset so that lines going through a box are easier to see\n                    continue;\n                }\n\n                let data = typeof node.toJSON === 'function' ? node.toJSON() : node;\n                data.position = Utils.ensurePoint(data.position, () => [x,y]);\n\n                let block = this.addBlock(data, node.id);\n                imported.push(node.id);\n\n                let size = this.getBlockSize(block);\n                maxX = Math.max(maxX, data.position[0] + size[0]);\n                y = data.position[1] + size[1] + MARGIN;\n\n                nextNodes = nextNodes.concat(node.getNextNodes());\n            }\n            if (nextNodes.length) {\n                await this.importNodes(nextNodes, maxX + MARGIN, 0, imported);\n            }\n        },\n\n        incrementId(id = null) {\n            if (typeof id !== 'number' && (typeof id !== 'string' || id.length === 0)) {\n                id = this.nextBlockId;\n                this.nextBlockId++;\n            }\n            let int = Number.parseInt(id, 10);\n            if (!Number.isNaN(int)) {\n                this.nextBlockId = Math.max(this.nextBlockId, int+1);\n            }\n            return id;\n        },\n\n        /**\n         * Go to the perfect scale\n         */\n        perfectScale() {\n            if (!this.$refs.div || this.blocks.length === 0) {\n                return;\n            }\n\n            var xMin = null, xMax = null;\n            var yMin = null, yMax = null;\n\n            for (let block of this.blocks) {\n                let size = this.getBlockSize(block);\n                let pos = Utils.ensurePoint(block.position);\n                if (xMin == null) {\n                    xMin = pos[0]-15\n                    xMax = pos[0]+size[0]+15;\n                    yMin = pos[1]-15\n                    yMax = pos[1]+size[1]+15;\n                } else {\n                    xMin = Math.min(xMin, pos[0]-15);\n                    xMax = Math.max(xMax, pos[0]+size[0]+15);\n                    yMin = Math.min(yMin, pos[1]-15);\n                    yMax = Math.max(yMax, pos[1]+size[1]+15);\n                }\n            }\n\n            var rect = this.$refs.div.getBoundingClientRect();\n            var scaleA = rect.width/(xMax-xMin);\n            var scaleB = rect.height/(yMax-yMin);\n            this.state.scale = Math.min(scaleA, scaleB, 1.5); // Don't scale higher than 1.5\n            this.state.center = [\n                rect.width/2 - this.state.scale*(xMin+xMax)/2.0,\n                rect.height/2 - this.state.scale*(yMin+yMax)/2.0\n            ];\n            this.newBlockOffset = 0;\n        },\n\n        showParameterViewer(parameters, values, title, isEditable, selectParameterName, saveCallback, parent) {\n            this.parameterViewer = {\n                parameters,\n                values,\n                title,\n                selectParameterName,\n                parent\n            };\n        }\n    }\n};\n\nclass BlocksProcess {\n    constructor(process) {\n        Object.assign(this, process);\n    }\n}\n</script>\n\n<style lang=\"scss\">\n.vue-component.model-builder {\n\twidth: 100%;\n\theight: 100%;\n\tposition: relative;\n\n    &.editable.focus .blocks {\n        border-color: rgba(22, 102, 182, 0.3);\n    }\n\n    &:focus,\n    .blocks:focus,\n    .canvas:focus {\n        outline: 0;\n    }\n    \n    .canvas {\n        width: 100%;\n        height: 100%;\n        position: absolute;\n        z-index: 1;\n    }\n    \n    .blocks {\n        box-sizing: border-box;\n        border: 1px solid transparent;\n        overflow: hidden;\n        position: absolute;\n        z-index: 3;\n        width: 100%;\n        height: 100%;\n    }\n\n    &.compact .blockicon .delete,\n    &.compact .blockicon .info,\n    &.compact .blockicon .addDescription,\n    &.compact .blockId,\n    &.compact .editDescription, \n    &.scale_xs .blockicon,\n    &.scale_s .blockicon,\n    &.scale_xs .connector .text {\n        display: none;\n    }\n    .zoomInfo {\n        position: absolute;\n        top: 0;\n        right: 0;\n        display: inline-block;\n        padding: 0.3em;\n        background-color: #f9f9f9;\n        color: #000;\n        border-radius: 0 0 0 0.3em;\n        z-index: 5;\n    }\n    &.scale_xs .editDescription {\n        visibility: hidden;\n    }\n}\n</style>","import mod from \"-!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js??clonedRuleSet-82.use[1]!../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./ModelBuilder.vue?vue&type=script&lang=js\"; export default mod; export * from \"-!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js??clonedRuleSet-82.use[1]!../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./ModelBuilder.vue?vue&type=script&lang=js\"","import { render, staticRenderFns } from \"./ModelBuilder.vue?vue&type=template&id=cfd84820\"\nimport script from \"./ModelBuilder.vue?vue&type=script&lang=js\"\nexport * from \"./ModelBuilder.vue?vue&type=script&lang=js\"\nfunction injectStyles (context) {\n  \n  var style0 = require(\"./ModelBuilder.vue?vue&type=style&index=0&id=cfd84820&prod&lang=scss\")\nif (style0.__inject__) style0.__inject__(context)\n\n}\n\n/* normalize component */\nimport normalizer from \"!../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  injectStyles,\n  null,\n  null\n  ,true\n)\n\nexport default component.exports"],"names":["content","__esModule","default","module","id","locals","exports","add","__inject__","shadowRoot","___CSS_LOADER_EXPORT___","push","render","_vm","this","_c","_self","ref","class","classes","style","attrs","on","onMouseMove","onMouseDown","onMouseWheel","onKeyDown","$event","hasFocus","staticClass","_l","edges","edge","key","parameter1","parameter2","selected","inactive","issues","state","node","mount","unmounted","updateEdgePos","arguments","hiddenParameterRefEdges","linkingLine","_b","_e","selectRect","blocks","block","type","spec","position","origin","process_id","namespace","result","description","update","args","updateBlock","startDragBlock","scale","showZoomInfo","_v","parameterViewer","staticRenderFns","getDefaultState","Vue","observable","root","editable","compactMode","moving","selecting","center","mouse","Config","defaultScale","linkFrom","linkTo","MARGIN","selectionChangeWatcher","newVal","oldVal","Array","isArray","length","every","value","i","$emit","selectedBlocks","selectedEdges","name","components","Block","Edge","ParameterViewer","props","String","required","Boolean","Object","collections","processes","parent","parentSchema","historySize","Number","explicitZoom","height","data","isMounted","allMounted","newBlockOffset","history","historyPointer","process","freeze","processGraph","nextBlockId","nextEdgeId","clipboard","activeTransactions","computed","x","Math","min","current","start","y","width","abs","processRegistry","ProcessRegistry","count","get","Error","hasProcesses","processBlocks","filter","b","selectedSideEdge","selectedParameter","hasSelection","processParametersFromSchemas","parentParams","$parent","getPgParameters","map","callbackParams","getCallbackParameters","filteredParentParams","p1","find","p2","concat","watch","importPgParameters","BlocksProcess","import","propagate","undoOnError","immediate","handler","updateHiddenParameterRefEdges","checkAllMounted","beforeCreate","Utils","enableHtmlProps","created","supports","$on","msg","title","console","error","showParameterViewer","duplicate","bind","mounted","loadFontAwesome","moveCenter","onDocumentMouseUpFn","onDocumentMouseUp","document","addEventListener","perfectScale","beforeDestroy","removeEventListener","methods","pos","position1","position2","elem","$el","updateBlockArguments","removedParams","parameterRemoved","$set","commit","$nextTick","refreshEdges","updateBlockDescription","updateBlockPos","saveHistory","updateBlockResult","updateBlockSelected","unselectOthers","unselectAll","updateBlockSpec","parameterFields","newBlock","omitFromObject","assign","optional","deprecated","experimental","extra","setResultNode","hiddenRefs","argName","isObject","process_graph","refs","PgUtils","getRefs","from_parameter","isParameterScoped","parameter","getPgParameterById","getBlockParameter","warn","parameterNames","slice","includes","removeEdge","event","startDrag","refreshEdgesFor","values","updatePositions","$listeners","focus","$refs","div","link","unlink","multiSelect","box","getDimensions","boxIntersectsBox","e","boxIntersectsLine","toJSON","export","JSON","stringify","selectEdge","which","addEdge","allInputs","querySelectorAll","el","activeElement","captured","code","deleteSelected","ctrlKey","metaKey","navigator","readText","forEach","pickFromObject","text","parse","writeText","json","preventDefault","stopPropagation","getMousePos","dX","dY","deltaScale","pow","sign","deltaY","domBoundingBox","rect","getBoundingClientRect","offsetTop","top","max","documentElement","scrollTop","body","offsetLeft","left","scrollLeft","clientX","clientY","mousePos","getCirclePosition","distance","sqrt","x1","y1","x2","y2","sideSelected","shiftKey","collide","issue","clear","startTransaction","splice","shift","undo","historyStep","redo","step","index","element","getBlockById","foundNewResultNode","hasOtherBlocks","other","hasOutputEdges","getPositionForPageXY","deepClone","addBlock","createEdgesForArguments","addProcess","num","incrementId","hasText","replace","size","getBlockSize","ensurePoint","getNewBlockDefaultPosition","blockSize","dim","inputs","parameters","blockWidth","compactParams","normalParams","compact","normal","commentHeight","reset","select","eraseEdge","$delete","indexOf","removeBlock","param","conflictBlock","otherBlock","hiddenParameterRef","findIndex","blockId","allowsDelete","addEdgeByNames","b1","b2","output","allSuccessors","getEdgeCount","allowsMultipleInputs","equals","JsonSchemaValidator","isSchemaCompatible","schema","outputParameter","explored","exploreList","currentBlock","pop","block1","target","block2","toggleCompact","internal","keys","copy","nodeId","substr","parameterBlocks","fn","options","success","error2","ProcessGraph","pg","setParent","parentProcessId","parentParameterName","allowEmpty","getProcessParameters","importNodes","getStartNodes","importEdges","params","addPgParameter","p","nodes","getNodes","Promise","all","importEdgesForNode","getArgumentNames","arg","val","getRawArgument","getArgumentType","from_node","importEdgeDeep","k","isRef","imported","nextNodes","maxX","undefined","getPreviousNodes","prev","getNextNodes","int","parseInt","isNaN","xMin","xMax","yMin","yMax","scaleA","scaleB","isEditable","selectParameterName","saveCallback","constructor","injectStyles","context","style0","component"],"ignoreList":[],"sourceRoot":""}