{"version":3,"file":"openeo.8403.js","mappings":";;;;;AAAA,YAAY,mBAAO,CAAC,IAAqB;;AAEzC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,GAAG;AACf,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,GAAG;AACf,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,GAAG;AACf,YAAY,GAAG;AACf,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,cAAc;AAC1B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,cAAc;AAC1B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,UAAU;AACtB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,UAAU;AACtB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,GAAG;AACf,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,GAAG;AACf,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,GAAG;AAClB,iBAAiB,GAAG;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,cAAc,QAAQ;AACtB;AACA;AACA,wCAAwC;AACxC;AACA;AACA,uBAAuB;AACvB;AACA,wCAAwC;AACxC;AACA;AACA;;AAEA;AACA,4CAA4C,IAAI;AAChD;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA,mDAAmD;AACnD;AACA;AACA;AACA,gCAAgC,oBAAoB,sCAAsC;AAC1F;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,mCAAmC;AACjF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,GAAG;AACf,YAAY,QAAQ;AACpB,cAAc;AACd;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,YAAY,OAAO;AACnB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,uB;;;;;;;ACjUA,cAAc,mBAAO,CAAC,GAAS;;AAE/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,qEAAqE,WAAW,WAAW;AAC3F;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,cAAc;AACd,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;AACjC,sHAAsH;AACtH;AACA;;;AAGA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,cAAc;AACd,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,qBAAqB;AACjC,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,UAAU;AACV;AACA;;AAEA,8B;;;;;;;ACxMA;AACA,4BAA4B,mBAAO,CAAC,IAAwB;AAC5D,2BAA2B,mBAAO,CAAC,IAAuB;AAC1D,yBAAyB,mBAAO,CAAC,IAAqB;AACtD;AACA,wBAAwB,mBAAO,CAAC,IAAmB;AACnD,yBAAyB,mBAAO,CAAC,IAAoB;AACrD,sBAAsB,mBAAO,CAAC,IAAiB;AAC/C,qBAAqB,mBAAO,CAAC,GAAgB;AAC7C,wBAAwB,mBAAO,CAAC,IAAmB;AACnD;AACA,iBAAiB,mBAAO,CAAC,IAAY;AACrC,cAAc,mBAAO,CAAC,GAAS;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;ACzBa;;AAEb;AACA;AACA,E;;;;;;;;;;;ACJA;;AAEA;AACA;AACA;;AAEe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AC/FA,cAAc,mBAAO,CAAC,GAAS;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,gBAAgB;AAC5B,YAAY,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,yBAAyB,gBAAgB,wBAAwB;AACjE;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iC;;;;;;;ACpNA,QAAQ,qCAAqC,EAAE,mBAAO,CAAC,IAAkB;;AAEzE;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB,YAAY,aAAa,mBAAmB;AAC5C,cAAc,iBAAiB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,GAAG;AACf;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,cAAc,UAAU;AACxB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kEAAkE;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,SAAS;AACrB,YAAY,aAAa;AACzB,YAAY,aAAa;AACzB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0B;;;;;;;AC7GA,cAAc,mBAAO,CAAC,GAAa;AACnC,iBAAiB,mBAAO,CAAC,IAAgB;;AAEzC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,gC;;;;;;;AC9CA,cAAc,mBAAO,CAAC,GAAS;;AAE/B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,gCAAgC;AAC5C,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,GAAG;AACf,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,QAAQ;AACpB;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA,qCAAqC;AACrC;AACA;AACA,uCAAuC;AACvC;;AAEA;AACA;AACA;AACA,+CAA+C,WAAW,IAAI;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,SAAS;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,iC;;;;;;;AC3PA,qBAAqB,mBAAO,CAAC,GAAgB;AAC7C,wBAAwB,mBAAO,CAAC,IAAmB;AACnD,cAAc,mBAAO,CAAC,GAAS;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B,YAAY,GAAG;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,cAAc;AACd;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,YAAY,SAAS;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;;AAEA;;AAEA,+B;;;;;;;ACzJA,cAAc,mBAAO,CAAC,GAAa;AACnC,iBAAiB,mBAAO,CAAC,IAAgB;AACzC,uBAAuB,mBAAO,CAAC,IAAc;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,oC;;;;;;;ACnSA,sBAAsB,mBAAO,CAAC,IAAiB;;AAE/C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA,kC;;;;;;;ACtBA,cAAc,mBAAO,CAAC,GAAa;AACnC,iBAAiB,mBAAO,CAAC,IAAgB;AACzC,uBAAuB,mBAAO,CAAC,IAAc;;AAE7C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,sDAAsD,QAAQ;AAC9D;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,oDAAoD;AACpD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kC;;;;;;;AC7OA,cAAc,mBAAO,CAAC,GAAa;AACnC,iBAAiB,mBAAO,CAAC,IAAgB;AACzC,uBAAuB,mBAAO,CAAC,IAAc;;AAE7C;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0GAA0G,QAAQ;AAClH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,aAAa;AAC5B,eAAe,SAAS;AACxB,eAAe,SAAS;AACxB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB,eAAe,QAAQ;AACvB,eAAe,SAAS;AACxB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kDAAkD,iBAAiB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA,sCAAsC,QAAQ,EAAE,KAAK;AACrD,8CAA8C,KAAK;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,iBAAiB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yDAAyD;AACzD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,eAAe,QAAQ;AACvB,eAAe,QAAQ;AACvB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4DAA4D;AAC5D;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;;AAEA,qC;;;;;;;;ACzaa;;AAEb;;;AAGA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,UAAU;AACjC;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,UAAU;AAC/B;;AAEA,qBAAqB,UAAU;AAC/B;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;ACvEO;AACA;AACP;AACA;AACA;AACA;AACA;AACA,+DAA+D,QAAQ;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP,oBAAoB,kCAAkC;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,iC;;ACpC+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA,eAAe,gBAAgB;AAC/B,eAAe,gBAAgB;AAC/B;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,2C;;AC5BuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,qCAAqC;AACrC,qCAAqC;AACrC,sCAAsC;AACtC,sCAAsC;AACtC;AACA;AACO;AACP;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E,UAAU;AACxF;AACA;AACA,6DAA6D,2BAA2B;AACxF;AACA;AACA,mC;;AC3CuC;AACwB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC,iCAAiC;AACjC;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,GAAG,IAAI,EAAE;AAChD;AACA;AACA;AACA;AACA,yBAAyB,GAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,OAAO;AACtB;AACA,+BAA+B,gBAAgB;AAC/C,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,eAAe;AACvB;AACA;AACA,QAAQ,eAAe;AACvB;AACA;AACA;AACA,qC;;ACjEoC;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,yBAAyB;AACzB,oBAAoB;AACpB;AACA;AACO,uFAAuF,MAAM;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,yBAAyB;AACzB,oBAAoB;AACpB;AACA;AACO;AACP;AACA,oC;;AC9BuC;AACgB;AACZ;AACc;AACzD,iC;;;;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACe;AACf;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,uBAAuB;AAC3D,MAAM;AACN;AACA;AACA;AACA;AACA;;;AC1ByC;;AAE1B;AACf,eAAe,YAAY;AAC3B;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oCAAoC;AACpC,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yDAAyD;AACzD;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA","sources":["webpack://vue-lib-openeo/./node_modules/@openeo/js-commons/src/utils.js","webpack://vue-lib-openeo/./node_modules/@openeo/js-commons/src/processUtils.js","webpack://vue-lib-openeo/./node_modules/@openeo/js-commons/src/main.js","webpack://vue-lib-openeo/./node_modules/css-loader/dist/runtime/noSourceMaps.js","webpack://vue-lib-openeo/./node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js","webpack://vue-lib-openeo/./node_modules/@openeo/js-commons/src/processDataType.js","webpack://vue-lib-openeo/./node_modules/@openeo/js-commons/src/versions.js","webpack://vue-lib-openeo/./node_modules/@openeo/js-commons/src/migrate/commons.js","webpack://vue-lib-openeo/./node_modules/@openeo/js-commons/src/processRegistry.js","webpack://vue-lib-openeo/./node_modules/@openeo/js-commons/src/processSchema.js","webpack://vue-lib-openeo/./node_modules/@openeo/js-commons/src/migrate/collections.js","webpack://vue-lib-openeo/./node_modules/@openeo/js-commons/src/processParameter.js","webpack://vue-lib-openeo/./node_modules/@openeo/js-commons/src/migrate/processes.js","webpack://vue-lib-openeo/./node_modules/@openeo/js-commons/src/migrate/capabilities.js","webpack://vue-lib-openeo/./node_modules/fast-deep-equal/es6/index.js","webpack://vue-lib-openeo/./node_modules/compare-versions/lib/esm/utils.js","webpack://vue-lib-openeo/./node_modules/compare-versions/lib/esm/compareVersions.js","webpack://vue-lib-openeo/./node_modules/compare-versions/lib/esm/compare.js","webpack://vue-lib-openeo/./node_modules/compare-versions/lib/esm/satisfies.js","webpack://vue-lib-openeo/./node_modules/compare-versions/lib/esm/validate.js","webpack://vue-lib-openeo/./node_modules/compare-versions/lib/esm/index.js","webpack://vue-lib-openeo/./node_modules/vue-style-loader/lib/listToStyles.js","webpack://vue-lib-openeo/./node_modules/vue-style-loader/lib/addStylesShadow.js"],"sourcesContent":["var equal = require('fast-deep-equal/es6');\n\n/**\n * General utilities\n * \n * @class\n */\nclass Utils {\n\n\t/**\n\t * Checks whether a variable is a real object or not.\n\t * \n\t * This is a more strict version of `typeof x === 'object'` as this example would also succeeds for arrays and `null`.\n\t * This function only returns `true` for real objects and not for arrays, `null` or any other data types.\n\t * \n\t * @param {*} obj - A variable to check.\n\t * @returns {boolean} - `true` is the given variable is an object, `false` otherwise.\n\t */\n\tstatic isObject(obj) {\n\t\treturn (typeof obj === 'object' && obj === Object(obj) && !Array.isArray(obj));\n\t}\n\n\t/**\n\t * Checks whether a variable is a string and contains at least one character.\n\t * \n\t * @param {*} string - A variable to check.\n\t * @returns {boolean} - `true` is the given variable is an string with length > 0, `false` otherwise.\n\t */\n\tstatic hasText(string) {\n\t\treturn (typeof string === 'string' && string.length > 0);\n\t}\n\n\t/**\n\t * Performs a deep comparison between two values to determine if they are equivalent.\n\t * \n\t * @param {*} x - The value to compare.\n\t * @param {*} y - The other value to compare.\n\t * @returns {boolean} - Returns true if the values are equivalent, else false.\n\t */\n\tstatic equals(x, y) {\n\t\treturn equal(x, y);\n\t}\n\n\t/**\n\t * Creates an object composed of the picked object properties.\n\t * \n\t * Returns a shallow copy!\n\t * \n\t * @param {object} obj - The source object.\n\t * @param {string|array} toPick - The properties to pick.\n\t * @returns {object}\n\t */\n\tstatic pickFromObject(obj, toPick) {\n\t\tobj = Object(obj);\n\t\tif (typeof toPick === 'string') {\n\t\t\ttoPick = [toPick];\n\t\t}\n\t\tconst copy = {};\n\t\ttoPick.forEach(key => copy[key] = obj[key]);\n\t\treturn copy;\n\t}\n\n\t/**\n\t * This method creates an object composed of the own and inherited enumerable property paths of object that are not omitted.\n\t * \n\t * Returns a shallow copy!\n\t * \n\t * @param {object} obj - The source object.\n\t * @param {string|array} toOmit - The properties to omit.\n\t * @returns {object}\n\t */\n\tstatic omitFromObject(obj, toOmit) {\n\t\tobj = Object(obj);\n\t\tif (typeof toOmit === 'string') {\n\t\t\ttoOmit = [toOmit];\n\t\t}\n\t\tvar copy = Object.assign({}, obj);\n\t\tfor(let key of toOmit) {\n\t\t\tdelete copy[key];\n\t\t}\n\t\treturn copy;\n\t}\n\n\t/**\n\t *  Creates an array of values by running each property of `object` thru function.\n\t * \n\t * The function is invoked with three arguments: (value, key, object).\n\t * \n\t * @param {object} obj \n\t * @param {function} func \n\t * @returns {object}\n\t */\n\tstatic mapObject(obj, func) {\n\t\t// Taken from lodash, see https://github.com/lodash/lodash/blob/master/mapObject.js\n\t\tconst props = Object.keys(obj);\n\t\tconst result = new Array(props.length);\n\t\tprops.forEach((key, index) => {\n\t\t\tresult[index] = func(obj[key], key, obj);\n\t\t});\n\t\treturn result;\n\t}\n\n\t/**\n\t * Creates an object with the same keys as object and values generated by running each own enumerable string keyed property of object thru the function.\n\t * \n\t * The function is invoked with three arguments: (value, key, object).\n\t * \n\t * @param {object} obj \n\t * @param {function} func \n\t * @returns {object}\n\t */\n\tstatic mapObjectValues(obj, func) {\n\t\t// Taken from lodash, see https://github.com/lodash/lodash/blob/master/mapValue.js\n\t\tobj = Object(obj);\n\t\tconst result = {};\n\t\tObject.keys(obj).forEach((key) => {\n\t\t\tresult[key] = func(obj[key], key, obj);\n\t\t});\n\t\treturn result;\n\t}\n\n\t/**\n\t * Creates a duplicate-free version of an array.\n\t * \n\t * If useEquals is set to true, uses the `Utils.equals` function for comparison instead of \n\t * the JS === operator. Thus, if the array contains objects, you likely want to set \n\t * `useEquals` to `true`.\n\t * \n\t * @param {array} array\n\t * @param {boolean} useEquals\n\t * @returns {array}\n\t */\n\tstatic unique(array, useEquals = false) {\n\t\tif (useEquals) {\n\t\t\treturn array.filter((s1, pos, arr) => arr.findIndex(s2 => Utils.equals(s1, s2)) === pos);\n\t\t}\n\t\telse {\n\t\t\treturn [...new Set(array)];\n\t\t}\n\t}\n\t\n\t/**\n\t * Computes the size of an array (number of array elements) or object (number of key-value-pairs).\n\t * \n\t * Returns 0 for all other data types.\n\t * \n\t * @param {*} obj \n\t * @returns {integer}\n\t */\n\tstatic size(obj) {\n\t\tif (typeof obj === 'object' && obj !== null) {\n\t\t\tif (Array.isArray(obj)) {\n\t\t\t\treturn obj.length;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn Object.keys(obj).length;\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\n\t/**\n\t * Checks whether a variable is numeric.\n\t * \n\t * Numeric is every string with numeric data or a number, excluding NaN and finite numbers.\n\t * \n\t * @param {*} n - A variable to check.\n\t * @returns {boolean} - `true` is the given variable is numeric, `false` otherwise.\n\t */\n\tstatic isNumeric(n) {\n\t\treturn !isNaN(parseFloat(n)) && isFinite(n);\n    }\n    \n    /**\n     * Deep clone for JSON-compatible data.\n     * \n     * @param {*} x - The data to clone.\n     * @returns {*} - The cloned data.\n     */\n    static deepClone(x) {\n\t\treturn JSON.parse(JSON.stringify(x));\n    }\n\n\t/**\n\t * Normalize a URL (mostly handling leading and trailing slashes).\n\t * \n\t * @static\n\t * @param {string} baseUrl - The URL to normalize\n\t * @param {string} path - An optional path to add to the URL\n\t * @returns {string} Normalized URL.\n\t */\n\tstatic normalizeUrl(baseUrl, path = null) {\n\t\tlet url = baseUrl.replace(/\\/$/, \"\"); // Remove trailing slash from base URL\n\t\tif (typeof path === 'string') {\n\t\t\tif (path.substr(0, 1) !== '/') {\n\t\t\t\tpath = '/' + path; // Add leading slash to path\n\t\t\t}\n\t\t\turl = url + path.replace(/\\/$/, \"\"); // Remove trailing slash from path\n\t\t}\n\t\treturn url;\n\t}\n\n\t/**\n\t * Replaces placeholders in this format: `{var}`.\n\t * \n\t * This can be used for the placeholders/variables in the openEO API's errors.json file.\n\t * \n\t * @param {string} message - The string to replace the placeholders in.\n\t * @param {object} variables - A map with the placeholder names as keys and the replacement value as value.\n\t */\n\tstatic replacePlaceholders(message, variables = {}) {\n\t\tif (typeof message === 'string' && Utils.isObject(variables)) {\n\t\t\tfor(var placeholder in variables) {\n\t\t\t\tlet vars = variables[placeholder];\n\t\t\t\tmessage = message.replace('{' + placeholder + '}', Array.isArray(vars) ? vars.join(\"; \") : vars);\n\t\t\t}\n\t\t}\n\t\treturn message;\n\t}\n\n\t/**\n\t * Compares two strings case-insensitive, including natural ordering for numbers.\n\t * \n\t * @param {string} a \n\t * @param {string} b \n\t * @returns {integer} Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters).\n\t */\n    static compareStringCaseInsensitive(a, b) {\n        if (typeof a !== 'string') {\n            a = String(a);\n        }\n        if (typeof b !== 'string') {\n            b = String(b);\n        }\n        return a.localeCompare(b, undefined, {numeric: true, sensitivity: 'base'});\n    }\n\n\t/**\n\t * Tries to make a string more readable by capitalizing it.\n\t * Only applies to words with more than two characters.\n\t * \n\t * Supports converting from:\n\t * - Snake Case (abc_def => Abc Def)\n\t * - Kebab Case (abc-def => Abc Def)\n\t * - Camel Case (abcDef => Abc Def)\n\t * \n\t * Doesn't capitalize if the words are not in any of the casing formats above.\n\t * \n\t * @param {*} strings - String(s) to make readable\n\t * @param {string} arraySep - String to separate array elements with\n\t * @returns {string}\n\t */\n    static prettifyString(strings, arraySep = '; ') {\n\t\tif (!Array.isArray(strings)) {\n\t\t\tstrings = [String(strings)];\n\t\t}\n\t\tstrings = strings.map(str => {\n\t\t\tif (str.length >= 3) {\n\t\t\t\tconst replacer = (_,a,b) => a + ' ' + b.toUpperCase();\n\t\t\t\tif (str.includes('_')) {\n\t\t\t\t\t// Snake case converter\n\t\t\t\t\tstr = str.replace(/([a-zA-Z\\d])_([a-zA-Z\\d])/g, replacer);\n\t\t\t\t}\n\t\t\t\telse if (str.includes('-')) {\n\t\t\t\t\t// Kebab case converter\n\t\t\t\t\tstr = str.replace(/([a-zA-Z\\d])-([a-zA-Z\\d])/g, replacer);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Camelcase converter\n\t\t\t\t\tstr = str.replace(/([a-z])([A-Z])/g, replacer);\n\t\t\t\t}\n\t\t\t\t// Uppercase the first letter in the first word, too.\n\t\t\t\treturn str.charAt(0).toUpperCase() + str.substr(1);\n\t\t\t}\n\t\t\treturn str;\n\t\t});\n\t\treturn strings.join(arraySep);\t\n    }\n\n\t/**\n\t * Makes link lists from the openEO API more user-friendly.\n\t * \n\t * Supports:\n\t * - Set a reasonable title, if not available. Make title more readable.\n\t * - Sorting by title (see `sort` parameter)\n\t * - Removing given relation types (`rel` property, see `ignoreRel` parameter)\n\t * \n\t * @param {array} linkList - List of links\n\t * @param {boolean} sort - Enable/Disable sorting by title. Enabled (true) by default.\n\t * @param {array} ignoreRel - A list of rel types to remove. By default, removes the self links (rel type = `self`).\n\t * @returns {array}\n\t */\n    static friendlyLinks(linkList, sort = true, ignoreRel = ['self']) {\n        let links = [];\n        if (!Array.isArray(linkList)) {\n            return links;\n        }\n\n        for(let link of linkList) {\n            link = Object.assign({}, link); // Make sure to work on a copy\n            if (typeof link.rel === 'string' && ignoreRel.includes(link.rel.toLowerCase())) {\n                continue;\n            }\n            if (typeof link.title !== 'string' || link.title.length === 0) {\n                if (typeof link.rel === 'string' && link.rel.length > 1) {\n                    link.title = Utils.prettifyString(link.rel);\n                }\n                else {\n                    link.title = link.href.replace(/^https?:\\/\\/(www.)?/i, '').replace(/\\/$/i, '');\n                }\n            }\n            links.push(link);\n        }\n        if (sort) {\n            links.sort((a, b) => Utils.compareStringCaseInsensitive(a.title, b.title));\n        }\n        return links;\n    }\n\n}\n\nmodule.exports = Utils;","const Utils = require('./utils');\n\n/**\n * Utilities to parse process specs and JSON schemas.\n * \n * @class\n */\nclass ProcessUtils {\n\n\t/**\n\t * From a \"complex\" JSON Schema with allOf/anyOf/oneOf, make separate schemas.\n\t * \n\t * So afterwards each schema has it's own array entry.\n\t * It merges allOf, resolves anyOf/oneOf into separate schemas.\n\t * May also split the JSON Schema type arrays into separate entries by setting `splitTypes` to `true`.\n\t * \n\t * @param {object|array} schemas - The JSON Schema(s) to convert\n\t * @returns {array}\n\t */\n\tstatic normalizeJsonSchema(schemas, splitTypes = false) {\n\t\t// Make schemas always an array\n\t\tif (Utils.isObject(schemas)) {\n\t\t\tschemas = [schemas];\n\t\t}\n\t\telse if (Array.isArray(schemas)) {\n\t\t\tschemas = schemas;\n\t\t}\n\t\telse {\n\t\t\tschemas = [];\n\t\t}\n\n\t\t// Merge allOf, resolve anyOf/oneOf into separate schemas\n\t\tlet normalized = [];\n\t\tfor(let schema of schemas) {\n\t\t\tif (Array.isArray(schema.allOf)) {\n\t\t\t\tnormalized.push(Object.assign({}, ...schema.allOf));\n\t\t\t}\n\t\t\telse if (Array.isArray(schema.oneOf) || Array.isArray(schema.anyOf)) {\n\t\t\t\tlet copy = Utils.omitFromObject(schema, ['oneOf', 'anyOf']);\n\t\t\t\tlet subSchemas = schema.oneOf || schema.anyOf;\n\t\t\t\tfor(let subSchema of subSchemas) {\n\t\t\t\t\tnormalized.push(Object.assign({}, copy, subSchema));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnormalized.push(schema);\n\t\t\t}\n\t\t}\n\n\t\tif (!splitTypes) {\n\t\t\treturn normalized;\n\t\t}\n\n\t\t// Split type field into separate schemas\n\t\tschemas = [];\n\t\tfor(let schema of normalized) {\n\t\t\tif (Array.isArray(schema.type)) {\n\t\t\t\t/* jshint ignore:start */\n\t\t\t\tschemas = schemas.concat(schema.type.map(type => Object.assign({}, schema, {type: type})));\n\t\t\t\t/* jshint ignore:end */\n\t\t\t}\n\t\t\telse {\n\t\t\t\tschemas.push(schema);\n\t\t\t}\n\t\t}\n\n\t\treturn schemas;\n\t}\n\n\t/**\n\t * Returns the callback parameters for a given process parameter.\n\t * \n\t * @param {object} processParameter - The process parameter spec to parse.\n\t * @returns {array}\n\t * @throws {Error}\n\t */\n\tstatic getCallbackParameters(processParameter, keyPath = []) {\n\t\tif (!Utils.isObject(processParameter) || !processParameter.schema) {\n\t\t\treturn [];\n\t\t}\n\n\t\tlet schemas = ProcessUtils.normalizeJsonSchema(processParameter.schema);\n\t\tlet key;\n\t\twhile(key = keyPath.shift()) { // jshint ignore:line\n\t\t\tschemas = schemas.map(schema => ProcessUtils.normalizeJsonSchema(ProcessUtils.getElementJsonSchema(schema, key))); // jshint ignore:line\n\t\t\tschemas = schemas.concat(...schemas);\n\t\t}\n\n\n\t\tlet cbParams = [];\n\t\tfor(let schema of schemas) {\n\t\t\tlet params = null;\n\t\t\tif (Array.isArray(schema.parameters)) { // For \"normal\" callbacks\n\t\t\t\tparams = schema.parameters;\n\t\t\t}\n\t\t\telse if (Utils.isObject(schema.additionalProperties) && Array.isArray(schema.additionalProperties.parameters)) {\n\t\t\t\tparams = schema.additionalProperties.parameters; // Used for metadata-filter\n\t\t\t}\n\t\t\tif (Array.isArray(params)) {\n\t\t\t\tif (cbParams.length > 0 && !Utils.equals(cbParams, params)) {\n\t\t\t\t\tthrow new Error(\"Multiple schemas with different callback parameters found.\");\n\t\t\t\t}\n\t\t\t\tcbParams = params;\n\t\t\t}\n\t\t}\n\n\t\treturn cbParams;\n\t}\n\n\t/**\n\t * Returns the callback parameters for a given process parameter from a full process spec.\n\t * \n\t * @param {object} process - The process to parse.\n\t * @param {string} parameterName - The name of the parameter to get the callback parameters for.\n\t * @returns {array}\n\t * @throws {Error}\n\t */\n\tstatic getCallbackParametersForProcess(process, parameterName, path = []) {\n\t\tif (!Utils.isObject(process) || !Array.isArray(process.parameters)) {\n\t\t\treturn [];\n\t\t}\n\n\t\tlet param = process.parameters.find(p => p.name === parameterName);\n\t\treturn ProcessUtils.getCallbackParameters(param, path);\n\t}\n\n\t/**\n\t * Returns *all* the native JSON data types allowed for the schema.\n\t * \n\t * @param {object} schema \n\t * @param {boolean} anyIsEmpty\n\t * @returns {array}\n\t */\n\tstatic getNativeTypesForJsonSchema(schema, anyIsEmpty = false) {\n\t\tif (Utils.isObject(schema) && Array.isArray(schema.type)) {\n\t\t\t// Remove duplicate and invalid types\n\t\t\tlet validTypes = Utils.unique(schema.type).filter(type => ProcessUtils.JSON_SCHEMA_TYPES.includes(type));\n\t\t\tif (validTypes.length > 0 && validTypes.length < ProcessUtils.JSON_SCHEMA_TYPES.length) {\n\t\t\t\treturn validTypes;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn anyIsEmpty ? [] : ProcessUtils.JSON_SCHEMA_TYPES;\n\t\t\t}\n\t\t}\n\t\telse if (Utils.isObject(schema) && typeof schema.type === 'string' && ProcessUtils.JSON_SCHEMA_TYPES.includes(schema.type)) {\n\t\t\treturn [schema.type];\n\t\t}\n\t\telse {\n\t\t\treturn anyIsEmpty ? [] : ProcessUtils.JSON_SCHEMA_TYPES;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the schema for a property of an object or an element of an array.\n\t * \n\t * If you want to retrieve the schema for a specific key, use the parameter `key`.\n\t * \n\t * @param {object} schema - The JSON schema to parse.\n\t * @param {string|integer|null} key - If you want to retrieve the schema for a specific key, otherwise null.\n\t * @returns {object} - JSON Schema\n\t */\n\tstatic getElementJsonSchema(schema, key = null) {\n\t\tlet types = ProcessUtils.getNativeTypesForJsonSchema(schema);\n\t\tif (Utils.isObject(schema) && types.includes('array') && typeof key !== 'string') {\n\t\t\tif (Utils.isObject(schema.items)) {\n\t\t\t\t// Array with one schema for all items: https://json-schema.org/understanding-json-schema/reference/array.html#id5\n\t\t\t\treturn schema.items;\n\t\t\t}\n\t\t\telse if (Array.isArray(schema.items)) {\n\t\t\t\t// Tuple validation: https://json-schema.org/understanding-json-schema/reference/array.html#id6\n\t\t\t\tif (key !== null && Utils.isObject(schema.items[key])) {\n\t\t\t\t\treturn schema.items[key];\n\t\t\t\t}\n\t\t\t\telse if (Utils.isObject(schema.additionalItems)) {\n\t\t\t\t\treturn schema.additionalItems;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (Utils.isObject(schema) && types.includes('object')) {\n\t\t\tif (key !== null && Utils.isObject(schema.properties) && Utils.isObject(schema.properties[key])) {\n\t\t\t\treturn schema.properties[key];\n\t\t\t}\n\t\t\telse if (Utils.isObject(schema.additionalProperties)) {\n\t\t\t\treturn schema.additionalProperties;\n\t\t\t}\n\t\t\t// ToDo: No support for patternProperties yet\n\t\t}\n\n\t\treturn {};\n\t}\n\n}\n\n/**\n * A list of all allowed JSON Schema type values.\n * \n * @type {array}\n */\nProcessUtils.JSON_SCHEMA_TYPES = ['string', 'number', 'integer', 'boolean', 'array', 'object', 'null'];\n\nmodule.exports = ProcessUtils;","// Migrations\nconst MigrateCapabilities = require('./migrate/capabilities');\nconst MigrateCollections = require('./migrate/collections');\nconst MigrateProcesses = require('./migrate/processes');\n// Processes\nconst ProcessDataType = require('./processDataType');\nconst ProcessParameter = require('./processParameter');\nconst ProcessSchema = require('./processSchema');\nconst ProcessUtils = require('./processUtils');\nconst ProcessRegistry = require('./processRegistry');\n// Others\nconst Versions = require('./versions');\nconst Utils = require('./utils');\n\nmodule.exports = {\n\tMigrateCapabilities,\n\tMigrateCollections,\n\tMigrateProcesses,\n\tProcessDataType,\n\tProcessParameter,\n\tProcessSchema,\n\tProcessUtils,\n\tProcessRegistry,\n\tVersions,\n\tUtils,\n};","\"use strict\";\n\nmodule.exports = function (i) {\n  return i[1];\n};","/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nexport default function normalizeComponent(\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */,\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options =\n    typeof scriptExports === 'function' ? scriptExports.options : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) {\n    // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () {\n          injectStyles.call(\n            this,\n            (options.functional ? this.parent : this).$root.$options.shadowRoot\n          )\n        }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functional component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection(h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing ? [].concat(existing, hook) : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n","const Utils = require('./utils');\n\n/**\n * Wrapper class for a single data type definition in a schema (e.g. process parameter schema, return value schema).\n * \n * @class\n */\nclass ProcessDataType {\n\t\n\t/**\n\t * Constructs a new process data type based on JSON Schema.\n\t * \n\t * @param {object} schema\n\t * @param {?ProcessSchema} [parent=null]\n\t * @param {*} [defaultValue=undefined]\n\t */\n\tconstructor(schema, parent = null, defaultValue = undefined) {\n\t\tthis.schema = schema;\n\t\tif (typeof this.schema.default === 'undefined') {\n\t\t\tthis.schema.default = defaultValue;\n\t\t}\n\t\tthis.parent = parent;\n\t}\n\n\t/**\n\t * Converts the schema to a JSON-serializable representation.\n\t * \n\t * @returns {object}\n\t */\n\ttoJSON() {\n\t\treturn Object.assign({}, this.schema, {default: this.default()});\n\t}\n\n\t/**\n\t * Checks whether the data type is only `null`.\n\t * \n\t * @returns {boolean}\n\t */\n\tisAny() {\n\t\treturn this.dataType() === 'any';\n\t}\n\n\t/**\n\t * Checks whether the data type is only `null`.\n\t * \n\t * @returns {boolean}\n\t */\n\tisNull() {\n\t\treturn this.schema.type === 'null';\n\t}\n\n\t/**\n\t * Checks whether the data type allows `null`.\n\t * \n\t * @returns {boolean}\n\t */\n\tnullable() {\n\t\treturn this.isNull() || this.isAny();\n\t}\n\n\t/**\n\t * Returns whether the data type is editable.\n\t * \n\t * This means it returns `true`, unless certain data types are detected that\n\t * can't be transmitted via JSON in the openEO API (e.g. data cubes or labeled arrays).\n\t * \n\t * @returns {boolean}\n\t */\n\tisEditable() {\n\t\treturn !ProcessDataType.NON_EDITABLE.includes(this.dataType());\n\t}\n\n\t/**\n\t * Returns the data type.\n\t * \n\t * The priority is as such:\n\t * - subtype\n\t * - native data type\n\t * - \"any\"\n\t * \n\t * @param {boolean} [native=false] - Set to true to only return the native data type.\n\t * @returns {string}\n\t */\n\tdataType(native = false) {\n\t\tlet nativeType = this.schema.type || \"any\";\n\t\treturn native ? nativeType : (this.schema.subtype || nativeType);\n\t}\n\n\t/**\n\t * Returns the native data type of the schema.\n\t * \n\t * One of: array, object, null, string, boolean, number or any\n\t * \n\t * @returns {string}\n\t */\n\tnativeDataType() {\n\t\treturn this.dataType(true);\n\t}\n\n\t/**\n\t * Checks whether the data type contains an enumeration of values.\n\t * \n\t * @returns {boolean}\n\t * @see ProcessDataType#getEnumChoices\n\t */\n\tisEnum() {\n\t\treturn Array.isArray(this.schema.enum) && this.schema.enum.length > 0;\n\t}\n\n\t/**\n\t * Returns the allowed enumeration of values.\n\t * \n\t * @returns {array}\n\t * @see ProcessDataType#isEnum\n\t */\n\tgetEnumChoices() {\n\t\treturn this.isEnum() ? this.schema.enum : [];\n\t}\n\n\t/**\n\t * Returns the parameters for a \"child process\" that is defined for the data type.\n\t * \n\t * @returns {array<object>}\n\t */\n\tgetCallbackParameters() {\n\t\tif (Array.isArray(this.schema.parameters)) { // For \"normal\" callbacks\n\t\t\treturn this.schema.parameters;\n\t\t}\n\t\telse if (Utils.isObject(this.schema.additionalProperties) && Array.isArray(this.schema.additionalProperties.parameters)) {\n\t\t\treturn this.schema.additionalProperties.parameters; // Used for metadata-filter\n\t\t}\n\t\telse {\n\t\t\treturn [];\n\t\t}\n\t}\n\n\t/**\n\t * Returns the group of the data type.\n\t * \n\t * Group is a \"extension\" of JSON Schema, which allows to group schemas by certain criteria.\n\t * \n\t * @returns {string}\n\t */\n\tgroup() {\n\t\treturn Utils.hasText(this.schema.group) ? this.schema.group : ProcessDataType.DEFAULT_GROUP;\n\t}\n\n\t/**\n\t * Returns the title of the data type.\n\t * \n\t * If no title is present, returns a \"prettified\" version of the data type\n\t * (e.g. \"Temporal Interval\" for the data type \"temporal-interval\").\n\t * \n\t * @returns {string}\n\t */\n\ttitle() {\n\t\tif (Utils.hasText(this.schema.title)) {\n\t\t\treturn this.schema.title;\n\t\t}\n\t\telse {\n\t\t\treturn Utils.prettifyString(this.dataType());\n\t\t}\n\t}\n\n\t/**\n\t * Returns the description of the data type.\n\t * \n\t * @returns {string}\n\t */\n\tdescription() {\n\t\treturn Utils.hasText(this.schema.description) ? this.schema.description : \"\";\n\t}\n\n\t/**\n\t * Returns the default value of the data type.\n\t * \n\t * This may return `undefined`.\n\t * \n\t * @returns {*}\n\t */\n\tdefault() {\n\t\tif (typeof this.schema.default === 'function') {\n\t\t\treturn this.schema.default();\n\t\t}\n\t\treturn this.schema.default;\n\t}\n\n}\n\n/**\n * The name of the default group for schemas.\n * \n * Defaults to `Other`.\n * \n * @type {string}\n */\nProcessDataType.DEFAULT_GROUP = 'Other';\n/**\n * A list of data types that can't be edited.\n * \n * Non-editable data types can't be transmitted via JSON through the openEO API\n * (e.g. data cubes or labeled arrays).\n * \n * @type {array<string>}\n */\nProcessDataType.NON_EDITABLE = [\n\t'raster-cube',\n\t'vector-cube',\n\t'labeled-array',\n\t'datacube'\n];\n\nmodule.exports = ProcessDataType;","const { compare, compareVersions, validate } = require('compare-versions');\n\n/** Version Number related methods */\nclass Versions {\n\n\t/**\n\t * Compare [semver](https://semver.org/) version strings.\n\t * \n\t * @param {string} firstVersion First version to compare\n\t * @param {string} secondVersion Second version to compare\n\t * @param {string|null} operator Optional; Arithmetic operator to use (>, >=, =, <=, <, !=). Defaults to `null`.\n\t * @returns {boolean|integer} If operator is not `null`: true` if the comparison between the firstVersion and the secondVersion satisfies the operator, `false` otherwise. If operator is `null`: Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters).\n\t * ```\n\t */\n\tstatic compare(v1, v2, operator = null) {\n\t\tif (operator !== null) {\n\t\t\treturn compare(v1, v2, operator);\n\t\t}\n\t\telse {\n\t\t\treturn compareVersions(v1, v2);\n\t\t}\n\t}\n\n\t/**\n\t * Validate [semver](https://semver.org/) version strings.\n\t * \n\t * @param {*} version - Version number to validate\n\t * @returns - `true` if the version number is a valid semver version number, `false` otherwise.\n\t */\n\tstatic validate(version) {\n\t\treturn validate(version);\n\t}\n\n\t/**\n\t * Tries to determine the most suitable version from a well-known discovery document that software is compatible to.\n\t * \n\t * @static\n\t * @param {array} wkVersions - A well-known discovery document compliant to the API specification.\n\t * @param {boolean} preferProduction - Set to `false` to make no difference between production and non-production versions.\n\t * @param {string|null} minVersion - The minimum version that should be returned.\n\t * @param {string|null} maxVersion - The maximum version that should be returned.\n\t * @returns {object[]} - Gives a list that lists all compatible versions (as still API compliant objects) ordered from the most suitable to the least suitable.\n\t */\n\tstatic findCompatible(wkVersions, preferProduction = true, minVersion = null, maxVersion = null) {\n\t\tif (!Array.isArray(wkVersions) || wkVersions.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\tlet compatible = wkVersions.filter(c => {\n\t\t\tif (typeof c.url === 'string' && Versions.validate(c.api_version)) {\n\t\t\t\tlet hasMinVer = Versions.validate(minVersion);\n\t\t\t\tlet hasMaxVer = Versions.validate(maxVersion);\n\t\t\t\tif (hasMinVer && hasMaxVer) {\n\t\t\t\t\treturn Versions.compare(c.api_version, minVersion, \">=\") && Versions.compare(c.api_version, maxVersion, \"<=\");\n\t\t\t\t}\n\t\t\t\telse if (hasMinVer) {\n\t\t\t\t\treturn Versions.compare(c.api_version, minVersion, \">=\");\n\t\t\t\t}\n\t\t\t\telse if (hasMaxVer) {\n\t\t\t\t\treturn Versions.compare(c.api_version, maxVersion, \"<=\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t });\n\t\tif (compatible.length === 0) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn compatible.sort((c1, c2) => {\n\t\t\tlet p1 = c1.production === true;\n\t\t\tlet p2 = c2.production === true;\n\t\t\tif (!preferProduction || p1 === p2) {\n\t\t\t\treturn Versions.compare(c1.api_version, c2.api_version) * -1; // `* -1` to sort in descending order.\n\t\t\t}\n\t\t\telse if (p1) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Find the latest version from well-known discovery that applies to the specified rules.\n\t * \n\t * This is basically the same as calling `findCompatible` and using the first element from the result.\n\t * \n\t * @param {array} wkVersions - A well-known discovery document compliant to the API specification.\n\t * @param {boolean} preferProduction - Set to `false` to make no difference between production and non-production versions.\n\t * @param {string|null} minVersion - The minimum version that should be returned.\n\t * @param {string|null} maxVersion - The maximum version that should be returned.\n\t * @returns {object|null}\n\t */\n\tstatic findLatest(wkVersions, preferProduction = true, minVersion = null, maxVersion = null) {\n\t\tlet versions = Versions.findCompatible(wkVersions, preferProduction, minVersion, maxVersion);\n\t\tif (versions.length > 0) {\n\t\t\treturn versions[0];\n\t\t}\n\t\telse {\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n}\n\nmodule.exports = Versions;","const Utils = require('../utils.js');\nconst Versions = require('../versions.js');\n\nclass MigrateCommons {\n\n\tstatic migrateLinks(links, version, fallbackRel = 'related') {\n\t\tif (!Array.isArray(links)) {\n\t\t\treturn [];\n\t\t}\n\n\t\treturn links\n\t\t\t.filter(link => Utils.isObject(link) && typeof link.href === 'string')\n\t\t\t.map(link => {\n\t\t\t\tif (typeof link.rel !== 'string') {\n\t\t\t\t\tlink.rel = fallbackRel;\n\t\t\t\t}\n\t\t\t\treturn link;\n\t\t\t});\n\t}\n\n\tstatic migrateDiscoveryParameters(parameters, version) {\n\t\tif (Versions.compare(version, \"1.0.0-rc.2\", \"<=\")) {\n\t\t\tfor(var name in parameters) {\n\t\t\t\tif (!Utils.isObject(parameters[name])) {\n\t\t\t\t\tdelete parameters[name];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet type = parameters[name].type;\n\t\t\t\tif (typeof type === 'string') {\n\t\t\t\t\tparameters[name].type = [type, \"null\"];\n\t\t\t\t}\n\n\t\t\t\tlet example = parameters[name].example;\n\t\t\t\tif (typeof example !== 'undefined') {\n\t\t\t\t\tparameters[name].examples = [example];\n\t\t\t\t\tdelete parameters[name].example;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn parameters;\n\t}\n\n}\n\nmodule.exports = MigrateCommons;","const Utils = require('./utils');\n\n/**\n * Central registry for processes.\n * \n * @class\n */\nclass ProcessRegistry {\n\n\t/**\n\t * Creates a new registry of all processes.\n\t * \n\t * @param {Array.<object>|ProcessRegistry} [processes=[]] - Optionally, a list of predefined processes.\n\t * @param {boolean} [addNamespace=false] - Add a namespace property to processes if set to `true`.\n\t */\n\tconstructor(processes = [], addNamespace = false) {\n\t\t/**\n\t\t * List of listeners for change events.\n\t\t * @public\n\t\t */\n\t\tthis.listeners = [];\n\t\t/**\n\t\t * Object of namespaces and processes.\n\t\t * @protected\n\t\t * @type {object.<string,object.<string,object>>}\n\t\t */\n\t\tthis.processes = {};\n\t\t/**\n\t\t * Add a namespace property to processes if set to `true`.\n\t\t * @protected\n\t\t * @type {boolean}\n\t\t */\n\t\tthis.addNamespace = addNamespace;\n\n\t\t// Fill process list\n\t\tif (processes instanceof ProcessRegistry) {\n\t\t\tfor(let namespace in processes.processes) {\n\t\t\t\tthis.addAll(processes.processes[namespace]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthis.addAll(processes);\n\t\t}\n\t}\n\n\t/**\n\t * Event that is fired on changes, notifies listeners.\n\t * \n\t * @param {string} event - One of 'add', 'addAll' or 'remove'.\n\t * @param {*} data \n\t * @param {string} namespace \n\t */\n\tonChange(event, data, namespace) {\n\t\tfor(let listener of this.listeners) {\n\t\t\tlistener(event, data, namespace);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a list of processes for a given namespace.\n\t * \n\t * Replaces an existing process in the given namespace if it exists.\n\t * \n\t * Fires 'addAll' event.\n\t * \n\t * @param {Array.<object>} processes Optionally, a list of processes\n\t * @param {string} [namespace=\"backend\"] The namespace for the processes (defaults to 'backend', i.e. pre-defined processes)\n\t */\n\taddAll(processes, namespace = 'backend') {\n\t\tfor(var i in processes) {\n\t\t\tthis.add(processes[i], namespace, false);\n\t\t}\n\t\tthis.onChange('addAll', processes, namespace);\n\t}\n\n\t/**\n\t * Adds a single process to a given namespace.\n\t * \n\t * Replaces an existing process in the given namespace if it exists.\n\t * \n\t * Fires 'add' event.\n\t * \n\t * @param {object} processes A process definition\n\t * @param {string} [namespace=\"backend\"] The namespace for the process (defaults to 'backend', i.e. pre-defined processes)\n\t */\n\tadd(process, namespace = 'backend', fireEvent = true) {\n\t\tif (!Utils.isObject(process)) {\n\t\t\tthrow new Error(\"Invalid process; not an object.\");\n\t\t}\n\t\tif (typeof process.id !== 'string') {\n\t\t\tthrow new Error(\"Invalid process; no id specified.\");\n\t\t}\n\t\tif (typeof namespace !== 'string') {\n\t\t\tthrow new Error(\"Invalid namespace; not a string.\");\n\t\t}\n\n\t\tif (!this.processes[namespace]) {\n\t\t\tthis.processes[namespace] = {};\n\t\t}\n\t\tprocess = Object.assign(this.addNamespace ? {namespace} : {}, process);\n\t\tthis.processes[namespace][process.id] = process;\n\t\tif (fireEvent) {\n\t\t\tthis.onChange('add', process, namespace);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the count of all processes independant of the namespaces.\n\t * \n\t * @returns {number} \n\t */\n\tcount() {\n\t\treturn Utils.size(this.all());\n\t}\n\n\t/**\n\t * Returns all processes as a list, independant of the namespaces.\n\t * \n\t * @returns {Array.<object>} \n\t */\n\tall() {\n\t\tlet processes = [];\n\t\tfor(let ns in this.processes) {\n\t\t\tprocesses = processes.concat(Object.values(this.processes[ns]));\n\t\t}\n\t\treturn processes;\n\t}\n\n\t/**\n\t * Checks whether a namespace exists (i.e. at least one process for the namespace exists)\n\t * \n\t * @param {string} namespace The namespace\n\t * @returns {boolean}\n\t */\n\thasNamespace(namespace) {\n\t\tif(typeof namespace !== 'string') {\n\t\t\treturn false;\n\t\t}\n\t\treturn Boolean(this.processes[namespace]);\n\t}\n\n\t/**\n\t * Returns a (sorted) list of all available namespaces.\n\t * \n\t * @returns {Array.<string>} \n\t */\n\tnamespaces() {\n\t\treturn Object.keys(this.processes).sort();\n\t}\n\n\t/**\n\t * Returns all processes from a specific namespace.\n\t * \n\t * Returns an empty list if the namespace is not defined.\n\t * \n\t * @param {string} namespace The namespace of the processes to return (e.g. 'backend' for pre-defined processes)\n\t * @returns {Array.<object>} \n\t */\n\tnamespace(namespace) {\n\t\tif(typeof namespace !== 'string') {\n\t\t\treturn [];\n\t\t}\n\t\tlet processes = this.processes[namespace];\n\t\treturn processes ? Object.values(processes) : [];\n\t}\n\n\t/**\n\t * Checks whether a process with the given ID exists in the given namespace.\n\t * \n\t * If the namespace is set to `null` (default) then it checks both user processes and backend processes.\n\t * The default namespace for pre-defined processes is `backend`.\n\t * \n\t * @param {string} id The process identifier\n\t * @param {?string} [namespace=null] The namespace of the process\n\t * @returns {boolean} \n\t */\n\thas(id, namespace = null) {\n\t\treturn Boolean(this.get(id, namespace));\n\t}\n\t\n\t/**\n\t * Retrieve the process with the given ID fron the given namespace.\n\t * \n\t * If the namespace is set to `null` (default) then it retrieces from both (1) `user` processes and (2) `backend` processes\n\t * with preference to user processes on conflict. The default namespace for pre-defined processes is `backend`.\n\t * \n\t * @param {string} id The process identifier\n\t * @param {?string} [namespace=null] The namespace of the process\n\t * @returns {object} \n\t */\n\tget(id, namespace = null) {\n\t\tif (typeof id !== 'string') {\n\t\t\treturn null;\n\t\t}\n\n\t\t// If no namespace is set, prefer the user namespace over backend namespace\n\t\tif (namespace === null) {\n\t\t\treturn this.get(id, 'user') || this.get(id, 'backend');\n\t\t}\n\n\t\tif (this.processes[namespace]) {\n\t\t\treturn this.processes[namespace][id] || null;\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Removes a single process or a complete namespace from the registry.\n\t * \n\t * If nothing is given, removes the namespace 'user'.\n\t * If only a namespace is given, removes the whole namespace.\n\t * If only a process is given, removes a process from the namespace `user`.\n\t * If both parameters are given, removes a process from the given namespace.\n\t * \n\t * Returns `true` on succes, `false` on failure.\n\t * \n\t * Fires 'remove' event.\n\t * \n\t * @param {?string} [id=null] The process identifier\n\t * @param {?string} [namespace=\"user\"] The namespace, defaults to `user`\n\t * @returns {boolean}\n\t */\n\tremove(id = null, namespace = 'user') {\n\t\tif (typeof namespace !== 'string') {\n\t\t\treturn false;\n\t\t}\n\n\t\tif (this.processes[namespace]) {\n\t\t\tif (typeof id === 'string') {\n\t\t\t\tif (this.processes[namespace][id]) {\n\t\t\t\t\tlet process = this.processes[namespace][id];\n\t\t\t\t\tdelete this.processes[namespace][id];\n\t\t\t\t\tif (Utils.size(this.processes[namespace]) === 0) {\n\t\t\t\t\t\tdelete this.processes[namespace];\n\t\t\t\t\t}\n\t\t\t\t\tthis.onChange('remove', process, namespace);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdelete this.processes[namespace];\n\t\t\t\tthis.onChange('remove', null, namespace);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n}\n\nmodule.exports = ProcessRegistry;","const ProcessUtils = require('./processUtils');\nconst ProcessDataType = require('./processDataType');\nconst Utils = require('./utils');\n\n/**\n * Wrapper class for the process schemas (i.e. from parameters or return value).\n * \n * @class\n */\nclass ProcessSchema {\n\t\n\t/**\n\t * Constructs a new process schema based on the openEO API representation.\n\t * \n\t * Can be array or JSON Schema object. The array consists of multiple JSON Schemas then.\n\t * \n\t * @param {?object|array} [schema=null]\n\t * @param {*} [defaultValue=undefined]\n\t */\n\tconstructor(schema = null, defaultValue = undefined) {\n\t\tif (!Utils.isObject(schema) && !Array.isArray(schema)) {\n\t\t\tthis.unspecified = true;\n\t\t\tthis.schemas = [];\n\t\t}\n\t\telse {\n\t\t\tthis.unspecified = false;\n\t\t\tthis.schemas = ProcessUtils.normalizeJsonSchema(schema, true).map(s => new ProcessDataType(s, this, defaultValue));\n\n\t\t\t// Find and assign the default value from sub-schemas if no defaultValue was given\n\t\t\tif (typeof defaultValue === 'undefined') {\n\t\t\t\tlet defaults = this.schemas\n\t\t\t\t\t.map(s => s.default())\n\t\t\t\t\t.filter(d => typeof d !== 'undefined');\n\t\t\t\tthis.default = defaults[0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.default = defaultValue;\n\t\t\t}\n\t\t}\n\n\t\tthis.refs = [];\n\t}\n\n\t/**\n\t * Converts the schemas to a JSON-serializable representation.\n\t * \n\t * @returns {object}\n\t */\n\ttoJSON() {\n\t\treturn this.schemas.map(s => s.toJSON());\n\t}\n\n\t/**\n\t * Returns whether the schema is editable.\n\t * \n\t * This means it returns `true`, unless certain data types are detected that\n\t * can't be transmitted via JSON in the openEO API (e.g. data cubes or labeled arrays).\n\t * \n\t * @returns {boolean}\n\t */\n\tisEditable() {\n\t\treturn (this.unspecified || this.schemas.filter(s => s.isEditable() && !s.isNull()).length > 0);\n\t}\n\n\t/**\n\t * Checks whether the schema is exactly and only of the given data type.\n\t * \n\t * Can be a native type or a openEO \"subtype\".\n\t * \n\t * @param {string} type \n\t * @returns {boolean}\n\t */\n\tis(type) {\n\t\tvar types = this.dataTypes();\n\t\treturn (types.length === 1 && types[0] === type);\n\t}\n\n\t/**\n\t * Returns the native data type of the schema.\n\t * \n\t * One of: array, object, null, string, boolean, number\n\t * \n\t * @returns {string}\n\t */\n\tnativeDataType() {\n\t\treturn this.dataType(true);\n\t}\n\n\t/**\n\t * Returns the data type of the associated schemas.\n\t * \n\t * Setting `native` to `true` will only consider native JSON data types and \"any\".\n\t * Otherwise, subtypes will also be considered.\n\t * \n\t * If the schema has a two data types and one of them is `null`, \n\t * `null` is ignored and just the other data type is returned.\n\t * \n\t * `nullable()` can be used to check whether a schema allows `null`.\n\t * \n\t * Returns `mixed` if multiple data types are allowed.\n\t * \n\t * @param {boolean} [native=false]\n\t * @returns {string}\n\t * @see ProcessSchema#nullable\n\t */\n\tdataType(native = false) {\n\t\tvar types = this.dataTypes(true, native);\n\t\tvar nullIndex = types.indexOf('null');\n\t\tif (types.length === 1) {\n\t\t\treturn types[0];\n\t\t}\n\t\telse if (types.length === 2 && nullIndex !== -1) {\n\t\t\treturn types[nullIndex === 0 ? 1 : 0];\n\t\t}\n\t\telse {\n\t\t\treturn 'mixed';\n\t\t}\n\t}\n\n\t/**\n\t * Returns a set of all supported distinct data types (or 'any').\n\t * \n\t * By default, `null` is not included in the list of data types.\n\t * Setting `includeNull` to `true` to include `null` in the list.\n\t * \n\t * Setting `native` to `true` will only consider native JSON data types and \"any\".\n\t * Otherwise, subtypes will also be considered.\n\t * \n\t * @param {boolean} [includeNull=false]\n\t * @param {boolean} [native=false]\n\t * @returns {array<string>}\n\t */\n\tdataTypes(includeNull = false, native = false) {\n\t\tvar types = this.schemas\n\t\t\t.map(s => s.dataType(native))\n\t\t\t.filter((v, i, a) => a.indexOf(v) === i); // Return each type only once\n\t\tif (types.length === 0 || types.includes('any')) {\n\t\t\treturn ['any'];\n\t\t}\n\t\treturn includeNull ? types : types.filter(s => s !== 'null');\n\t}\n\n\t/**\n\t * Checks whether one of the schemas allows the value to be `null`.\n\t * \n\t * @returns {boolean}\n\t */\n\tnullable() {\n\t\treturn (this.unspecified || this.schemas.filter(s => s.nullable()).length > 0);\n\t}\n\n}\n\nmodule.exports = ProcessSchema;","const Utils = require('../utils.js');\nconst Versions = require('../versions.js');\nconst MigrateCommons = require('./commons.js');\n\nconst extMap = {\n    \"cube\": \"datacube\",\n    \"eo\": \"eo\",\n    \"label\": \"label\",\n    \"pc\": \"pointcloud\",\n    \"proj\": \"projection\",\n    \"sar\": \"sar\",\n    \"sat\": \"sat\",\n    \"sci\": \"scientific\",\n    \"view\": \"view\"\n};\n\nconst fieldMap = {\n    // Item to core\n    'item:license': 'license',\n    'item:providers': 'providers',\n    // EO to core\n    'eo:instrument': 'instruments',\n    'eo:platform': 'platform',\n    'eo:constellation': 'constellation',\n    // EO to proj\n    'eo:epsg': 'proj:epsg',\n    // EO to view\n    'eo:off_nadir': 'view:off_nadir',\n    'eo:azimuth': 'view:azimuth',\n    'eo:sun_azimuth': 'view:sun_azimuth',\n    'eo:sun_elevation': 'view:sun_elevation',\n    // Datetime Range to core\n    'dtr:start_datetime': 'start_datetime',\n    'dtr:end_datetime': 'end_datetime',\n    // Point Cloud\n    'pc:schema': 'pc:schemas',\n    // SAR rename\n    'sar:type': 'sar:product_type',\n    'sar:polarization': 'sar:polarizations',\n    // SAR to core\n    'sar:instrument': 'instruments',\n    'sar:platform': 'platform',\n    'sar:constellation': 'constellation',\n    // SAR to sat\n    'sar:off_nadir': 'sat:off_nadir_angle',\n    'sar:relative_orbit': 'sat:relative_orbit',\n// The following four fields don't translate directly, see code below\n    'sar:pass_direction': 'sat:orbit_state',\n//   sar:resolution => sar:resolution_range, sar:resolution_azimuth\n//   sar:pixel_spacing => sar:pixel_spacing_range, sar:pixel_spacing_azimuth\n//   sar:looks => sar:looks_range, sar:looks_azimuth, sar:looks_equivalent_number (opt)\n};\n\nconst moveToRoot = [\n    'cube:dimensions',\n    'sci:publications',\n    'sci:doi',\n    'sci:citation'\n];\n\nconst DIMENSION_TYPES = [\n    'spatial',\n    'temporal',\n    'bands',\n    'other'\n];\n\n\n/** Migrate Collections related responses to the latest version. */\nclass MigrateCollections {\n\n    /**\n     * Converts a `GET /collections` response to the latest version.\n     * \n     * Always returns a deep copy of the input object.\n     * \n     * @param {object} response - The response to convert\n     * @param {string} version - Version number of the API, which the response conforms to\n     * @returns {object}\n     */\n    static convertCollectionsToLatestSpec(response, version) {\n        if (Versions.compare(version, \"0.3.x\", \"<=\")) {\n            throw \"Migrating from API version 0.3.0 and older is not supported.\";\n        }\n\n        // Make sure we don't alter the original object\n        response = Utils.deepClone(response);\n\n        if (Array.isArray(response.collections)) {\n            response.collections = response.collections\n                .map(c => MigrateCollections.convertCollectionToLatestSpec(c, version))\n                .filter(c => typeof c.id === 'string');\n        }\n        else {\n            response.collections = [];\n        }\n\n        response.links = MigrateCommons.migrateLinks(response.links, version);\n\n        return response;\n    }\n\n    /**\n     * Converts a single collection to the latest version.\n     * \n     * Always returns a deep copy of the input object.\n     * \n     * @param {object} process - The collection to convert\n     * @param {string} version - Version number of the API, which the collection conforms to\n     * @returns {object}\n     */\n    static convertCollectionToLatestSpec(originalCollection, version) {\n        if (Versions.compare(version, \"0.3.x\", \"<=\")) {\n            throw \"Migrating from API version 0.3.0 and older is not supported.\";\n        }\n\n        // Make sure we don't alter the original object\n        let collection = Utils.deepClone(originalCollection);\n\n        // If collection has no id => seems to be an invalid collection => abort\n        if (typeof collection.id !== 'string' || collection.id.length === 0) {\n            return {};\n        }\n\n        // Update stac_version\n        if (!Versions.validate(collection.stac_version) || Versions.compare(collection.stac_version, \"0.9.0\", \"<\")) {\n            collection.stac_version = \"0.9.0\";\n        }\n\n        // Add missing extent upfront. Makes the following code simpler as it works on the object.\n        if (!Utils.isObject(collection.extent)) {\n            collection.extent = {};\n        }\n\n        // convert v0.4 collections to latest version\n        if (Versions.compare(version, \"0.4.x\", \"=\")) {\n            // Restructure spatial extent\n            if (Array.isArray(collection.extent.spatial)) {\n                collection.extent.spatial = {\n                    bbox: [\n                        collection.extent.spatial\n                    ]\n                };\n            }\n            // Restructure temporal extent\n            if (Array.isArray(collection.extent.temporal)) {\n                collection.extent.temporal = {\n                    interval: [\n                        collection.extent.temporal\n                    ]\n                };\n            }\n\n            // move properties to other_properties\n            if (Utils.isObject(collection.properties)) {\n                if (!Utils.isObject(collection.other_properties)) {\n                    collection.other_properties = {};\n                }\n                for(let key in collection.properties) {\n                    collection.other_properties[key] = {\n                        values: [\n                            collection.properties[key]\n                        ]\n                    };\n                }\n            }\n            delete collection.properties;\n\n            // now we can work on all properties and migrate to summaries\n            let props = Utils.isObject(collection.other_properties) ? collection.other_properties : {};\n            for(let key in props) {\n                let val = props[key];\n                if (Utils.isObject(val) && (Array.isArray(val.extent) || Array.isArray(val.values))) {\n                    if (Array.isArray(val.extent)) {\n                        props[key] = {\n                            min: val.extent[0],\n                            max: val.extent[1]\n                        };\n                    }\n                    else { // val.values is an array\n                        if (val.values.findIndex(v => !Array.isArray(v)) === -1) {\n                            if (val.values.length <= 1) {\n                                props[key] = val.values[0];\n                            }\n                            else {\n                                props[key] = val.values.reduce((a, b) => a.concat(b));\n                            }\n                        }\n                        else {\n                            props[key] = val.values;\n                        }\n                    }\n                }\n                else {\n                    // If not valid, move to top-level\n                    if (typeof collection[key] === 'undefined') {\n                        collection[key] = val;\n                    }\n                    delete props[key];\n                }\n            }\n            delete collection.other_properties;\n\n            if (!Utils.isObject(collection.summaries)) {\n                collection.summaries = {};\n            }\n            for(let key in props) {\n                let val = props[key];\n\n                if (key === 'sar:pass_direction') {\n                    // Convert null to geostationary\n                    val = val.map(v => v === null ? 'geostationary' : v);\n                }\n\n                // Convert arrays into separate fields as needed for some SAR fields\n                if ((key === 'sar:resolution' || key === 'sar:pixel_spacing' || key === 'sar:looks') && Array.isArray(val) && val.length >= 2) {\n                    collection.summaries[key + '_range'] = val.slice(0,1);\n                    collection.summaries[key + '_azimuth'] = val.slice(1,2);\n                    if (val.length > 2) {\n                        collection.summaries[key + '_equivalent_number'] = val.slice(2,3);\n                    }\n                }\n                // Do the renaming of fields\n                else if (typeof fieldMap[key] === 'string') {\n                    collection.summaries[fieldMap[key]] = val;\n                }\n                // Move invalid summaries to the top level\n                else if (moveToRoot.includes(key) && Array.isArray(val) && val.length === 1) {\n                    collection[key] = val[0];\n                }\n                // Do the general conversion\n                else {\n                    collection.summaries[key] = val;\n                }\n            }\n        }\n\n        // Add missing required fields\n        if (typeof collection.description !== 'string') {\n            collection.description = \"\";\n        }\n        if (!Utils.isObject(collection.extent.spatial)) {\n            collection.extent.spatial = {};\n        }\n        if (!Utils.isObject(collection.extent.temporal)) {\n            collection.extent.temporal = {};\n        }\n        if (typeof collection.license !== 'string') {\n            collection.license = \"proprietary\";\n        }\n        if (!Utils.isObject(collection.summaries)) {\n            collection.summaries = {};\n        }\n        if (!Utils.isObject(collection['cube:dimensions'])) {\n            collection['cube:dimensions'] = {};\n        }\n        else {\n            for(var name in collection['cube:dimensions']) {\n                if (Utils.isObject(collection['cube:dimensions'][name]) && !DIMENSION_TYPES.includes(collection['cube:dimensions'][name].type)) {\n                    collection['cube:dimensions'][name].type = 'other';\n                }\n            }\n        }\n\n        // Fix links\n        collection.links = MigrateCommons.migrateLinks(collection.links);\n\n        // Fix stac_extensions\n        var extensions = Array.isArray(collection.stac_extensions) ? collection.stac_extensions : [];\n        for(var key in collection) {\n            let ext = null;\n            let prefix = key.split(':', 1);\n            if (key === 'deprecated' || key === 'version') {\n                ext = 'version';\n            }\n            else if (typeof extMap[prefix] === 'string') {\n                ext = extMap[prefix];\n            }\n\n            if (ext !== null && !extensions.includes(ext)) {\n                extensions.push(ext);\n            }\n        }\n        extensions.sort();\n        collection.stac_extensions = extensions;\n\n        return collection;\n    }\n\n}\n\nmodule.exports = MigrateCollections;","const ProcessSchema = require('./processSchema');\n\n/**\n * Wrapper class for a process parameter.\n * \n * @class\n */\nclass ProcessParameter extends ProcessSchema {\n\n\t/**\n\t * Constructs a new process parameter based on the openEO API representation.\n\t * \n\t * @param {object} parameter \n\t */\n\tconstructor(parameter) {\n\t\tsuper(parameter.schema, parameter.default);\n\n\t\tObject.assign(this, parameter);\n\t}\n\n}\n\nmodule.exports = ProcessParameter;","const Utils = require('../utils.js');\nconst Versions = require('../versions.js');\nconst MigrateCommons = require('./commons.js');\n\n/** Migrate processes related responses to the latest version. */\nclass MigrateProcesses {\n\n    /**\n     * Converts a `GET /process` response to the latest version.\n     * \n     * Always returns a deep copy of the input object.\n     * \n     * @param {object} response - The response to convert\n     * @param {string} version - Version number of the API, which the response conforms to\n     * @returns {object}\n     */\n    static convertProcessesToLatestSpec(response, version) {\n        if (Versions.compare(version, \"0.3.x\", \"<=\")) {\n            throw \"Migrating from API version 0.3.0 and older is not supported.\";\n        }\n\n        // Make sure we don't alter the original object\n        response = Utils.deepClone(response);\n\n        if (Array.isArray(response.processes)) {\n            response.processes = response.processes\n                .map(p => MigrateProcesses.convertProcessToLatestSpec(p, version))\n                .filter(p => typeof p.id === 'string');\n        }\n        else {\n            response.processes = [];\n        }\n\n        response.links = MigrateCommons.migrateLinks(response.links, version);\n\n        return response;\n    }\n\n    /**\n     * Converts a single process to the latest version.\n     * \n     * Always returns a deep copy of the input object.\n     * \n     * @param {object} process - The process to convert\n     * @param {string} version - Version number of the API, which the process conforms to\n     * @returns {object}\n     */\n    static convertProcessToLatestSpec(process, version) {\n        if (Versions.compare(version, \"0.3.x\", \"<=\")) {\n            throw \"Migrating from API version 0.3.0 and older is not supported.\";\n        }\n\n        // Make sure we don't alter the original object\n        process = Utils.deepClone(process);\n\n        // If process has no id => seems to be an invalid process => abort\n        if (typeof process.id !== 'string' || process.id.length === 0) {\n            return {};\n        }\n\n        // Convert the parameters from object to array\n        if (Versions.compare(version, \"0.4.x\", \"=\")) {\n            // Determine the parameter order\n            if (!Array.isArray(process.parameter_order) || process.parameter_order.length === 0) {\n                process.parameter_order = [];\n                for(let param in process.parameters) {\n                    process.parameter_order.push(param);\n                }\n            }\n    \n            // Upgrade parameters and convert from array to object\n            let params = [];\n            for(let name of process.parameter_order) {\n                // Add name \n                let obj = {name: name};\n                if (Utils.isObject(process.parameters[name])) {\n                    Object.assign(obj, process.parameters[name]);\n                }\n\n                // Migrate from required to optional\n                if (!obj.required) {\n                    obj.optional = true;\n                }\n                delete obj.required;\n\n                // Add to list of ordered params\n                params.push(obj);\n            }\n            delete process.parameter_order;\n            process.parameters = params;\n        }\n\n        // Set required field description if not a string\n        if (typeof process.description !== 'string') {\n            process.description = \"\";\n        }\n\n        // Update parameters\n        if (Array.isArray(process.parameters)) {\n            for (var i = process.parameters.length-1; i >= 0; i--) {\n                let param = process.parameters[i];\n                if (!Utils.isObject(param)) {\n                    process.parameters.splice(i, 1);\n                    continue;\n                }\n\n                // Set required field description if not a string\n                if (typeof param.description !== 'string') {\n                    param.description = \"\";\n                }\n\n                // Upgrade parameter schema\n                process.parameters[i] = upgradeSchema(param, version);\n            }\n        }\n        else {\n            process.parameters = [];\n        }\n\n        // Update return value\n        if (!Utils.isObject(process.returns)) {\n            process.returns = {};\n        }\n        process.returns = upgradeSchema(process.returns, version, false);\n\n        // Remove process graphs from examples (and ensure there are arguments given)\n        if (Array.isArray(process.examples)) {\n            process.examples = process.examples.filter(example => Utils.isObject(example) && Utils.isObject(example.arguments));\n        }\n\n        if (typeof process.links !== 'undefined') { // links not required, so only apply if defined anyway\n            process.links = MigrateCommons.migrateLinks(process.links, version);\n        }\n\n        // Update process graph -> nothing to do yet\n\n        return process;\n    }\n\n}\n    \nfunction upgradeSchema(obj, version, isParam = true) {\n    var schema = {};\n    if (obj.schema && typeof obj.schema === 'object') { // array or object?\n        schema = obj.schema;\n    }\n\n    if (Versions.compare(version, \"0.4.x\", \"=\")) {\n        // Remove anyOf/oneOf wrapper\n        for(let type of ['anyOf', 'oneOf']) {\n            if (Array.isArray(schema[type])) {\n                // Parameters only: Move default value to parameter-level\n                if (isParam && typeof schema.default !== 'undefined') {\n                    obj.default = schema.default;\n                }\n                // Move array one level up, removing anyOf and oneOf\n                schema = schema[type];\n                break;\n            }\n        }\n\n        let moveMediaType = (Versions.compare(version, \"0.4.x\") <= 0 && typeof obj.media_type !== 'undefined');\n        let schemas = Array.isArray(schema) ? schema : [schema];\n        for(let subSchema of schemas) {\n            // Rename format to subtype recursively\n            subSchema = renameFormat(subSchema);\n\n            // Parameters only: Move default value to parameter-level\n            if (isParam && typeof subSchema.default !== 'undefined') {\n                obj.default = subSchema.default;\n                delete subSchema.default;\n            }\n\n            // Replace media_type field with contentMediaType from JSON Schemas\n            if (moveMediaType) {\n                subSchema.contentMediaType = obj.media_type;\n            }\n        }\n\n        // Remove the media type\n        if (moveMediaType) {\n            delete obj.media_type;\n        }\n    }\n\n    // Clients SHOULD automatically set `optional` to `true`, if a default value is specified.\n    if (Versions.compare(version, \"0.4.x\", \">\")) {\n        if (typeof obj.default !== 'undefined') {\n            obj.optional = true;\n        }\n    }\n\n    obj.schema = schema;\n    return obj;\n}\n\nfunction renameFormat(schema) {\n    if (Utils.isObject(schema) && typeof schema.type !== 'undefined' && typeof schema.format === 'string') {\n        switch(schema.format) {\n            case 'url':\n                schema.format = 'uri';\n                break;\n            case 'proj-definition':\n                schema.deprecated = true;\n                break;\n            case 'callback':\n                schema.format = 'process-graph';\n                if (Utils.isObject(schema.parameters)) {\n                    let params = [];\n                    for(let name in schema.parameters) {\n                        let paramSchema = schema.parameters[name];\n                        let param = {\n                            name: name,\n                            description: typeof paramSchema.description === 'string' ? paramSchema.description : \"\",\n                            schema: paramSchema\n                        };\n                        params.push(param);\n                    }\n                    schema.parameters = params;\n                }\n                break;\n        }\n\n        schema.subtype = schema.format;\n        // Leave format for \"well-known\" formats defined in JSON Schema\n        if (!['date-time', 'time', 'date', 'uri'].includes(schema.format)) {\n            delete schema.format;\n        }\n    }\n    for(let i in schema) {\n        if (schema[i] && typeof schema[i] === 'object') {\n            schema[i] = renameFormat(schema[i]);\n        }\n    }\n    return schema;\n}\n\nmodule.exports = MigrateProcesses;","const Utils = require('../utils.js');\nconst Versions = require('../versions.js');\nconst MigrateCommons = require('./commons.js');\n\nconst NO_VERSION = \"0.0.0\";\n\n/** Migrate capabilities related responses to the latest version. */\nclass MigrateCapabilities {\n\n    /**\n     * Tries to determine the API version from the capabilities object.\n     * \n     * Returns the version number, e.g. \"0.4.2\", \"1.0.0\" or \"0.0.0\" (if unknown).\n     * \n     * @param {object} capabilities \n     * @returns {string}\n     */\n    static guessApiVersion(capabilities) {\n        // No object passed\n        if (!Utils.isObject(capabilities)) {\n            return NO_VERSION;\n        }\n\n        // Get exact info from version fields\n        if (Versions.validate(capabilities.api_version)) {\n            return capabilities.api_version;\n        }\n        else if (Versions.validate(capabilities.version)) {\n            return capabilities.version;\n        }\n        // Now we are really guessing\n        else if (Array.isArray(capabilities.endpoints)) {\n            if (capabilities.endpoints.find(e => e.path === '/file_formats' || e.path === '/conformance' || e.path === '/files')) {\n                return \"1.0.0\";\n            }\n            else if (capabilities.endpoints.find(e => e.path === '/output_formats' || e.path === '/files/{user_id}')) {\n                return \"0.4.2\";\n            }\n            else if (!capabilities.backend_version && !capabilities.title && !capabilities.description && !capabilities.links) {\n                return \"0.3.1\";\n            }\n        }\n\n        // Can't determine version\n        return NO_VERSION;\n    }\n\n    /**\n     * Converts a `GET /` response to the latest version.\n     * \n     * Always returns a deep copy of the input object.\n     * \n     * @param {object} response - The response to convert\n     * @param {string|null} version - Version number of the API, which the response conforms to. If `null`, tries to guess the version with `guessApiVersion()`.\n     * @param {boolean} updateVersionNumbers - Should version numbers in the response be updated?\n     * @param {boolean} updateEndpointPaths - Should the endpoint paths be updated to their recent equivalents?\n     * @param {string} id - If no id is set in the response, sets it to the value specified here. Defaults to `unknown`.\n     * @param {string} title - If no title is set in the response, sets it to the value specified here. Defaults to `Unknown`.\n     * @param {string} title - If no backend_version is set in the response, sets it to the value specified here. Defaults to `0.0.0`.\n     * @returns {object}\n     */\n    static convertCapabilitiesToLatestSpec(originalCapabilities, version = null, updateVersionNumbers = true, updateEndpointPaths = true, id = \"unknown\", title = \"Unknown\", backend_version = \"0.0.0\") {\n        if (version === null) {\n            version = this.guessApiVersion(originalCapabilities);\n        }\n        // Return empty if version number is not available\n        if (version === NO_VERSION) {\n            return {};\n        }\n\n        if (Versions.compare(version, \"0.3.x\", \"<=\")) {\n            throw \"Migrating from API version 0.3.0 and older is not supported.\";\n        }\n\n        let capabilities = Utils.deepClone(originalCapabilities);\n        // Fill & Update version number\n        if (!updateVersionNumbers) {\n            capabilities.api_version = version;\n        }\n        else {\n            capabilities.api_version = \"1.0.0\";\n        }\n\n        // Convert billing plans\n        if (Utils.isObject(capabilities.billing)) {\n            capabilities.billing = this.convertBillingToLatestSpec(capabilities.billing, version);\n        }\n        else {\n            delete capabilities.billing;\n        }\n\n        // Convert endpoints\n        capabilities.endpoints = this.convertEndpointsToLatestSpec(capabilities.endpoints, version, updateEndpointPaths);\n\n        // Fill STAC Version field\n        if (!updateVersionNumbers && Versions.compare(version, \"0.4.x\", \"=\")) {\n            capabilities.stac_version = \"0.6.2\";\n        }\n        else if (updateVersionNumbers || typeof capabilities.stac_version !== 'string') {\n            capabilities.stac_version = \"0.9.0\";\n        }\n\n        // Add missing fields with somewhat useful data\n        if (typeof capabilities.production !== 'boolean') {\n            capabilities.production = Versions.compare(version, \"1.0.0-rc.1\", \"=\") || Versions.compare(version, \"1.0.0-rc.2\", \"=\") ? true : false;\n        }\n        if (typeof capabilities.backend_version !== 'string') {\n            capabilities.backend_version = backend_version;\n        }\n        if (typeof capabilities.id !== 'string') {\n            capabilities.id = id;\n        }\n        if (typeof capabilities.title !== 'string') {\n            capabilities.title = title;\n        }\n        if (typeof capabilities.description !== 'string') {\n            capabilities.description = \"\";\n        }\n        capabilities.links = MigrateCommons.migrateLinks(capabilities.links, version);\n\n        return capabilities;\n    }\n\n    /**\n     * Converts the billing part of the `GET /` response to the latest version.\n     * \n     * Always returns a deep copy of the input object.\n     * \n     * @param {object} billing - The response to convert\n     * @param {string} version - Version number of the API, which the response conforms to\n     * @returns {object}\n     */\n    static convertBillingToLatestSpec(billing, version) {\n        if (Versions.compare(version, \"0.3.x\", \"<=\")) {\n            throw \"Migrating from API version 0.3.0 and older is not supported.\";\n        }\n        if (Utils.isObject(billing)) {\n            billing = Utils.deepClone(billing);\n        }\n        else {\n            billing = {};\n        }\n\n        if (typeof billing.currency !== 'string') {\n            billing.currency = null;\n        }\n\n        return billing;\n    }\n\n    /**\n     * Converts the endpoints part of the `GET /` response to the latest version.\n     * \n     * Always returns a deep copy of the input object.\n     * \n     * @param {array} endpoints - The response to convert\n     * @param {string} version - Version number of the API, which the response conforms to\n     * @param {boolean} updatePaths - Should the endpoint paths be updated to their recent equivalents?\n     * @returns {array}\n     */\n    static convertEndpointsToLatestSpec(endpoints, version, updatePaths = false) {\n        if (Versions.compare(version, \"0.3.x\", \"<=\")) {\n            throw \"Migrating from API version 0.3.0 and older is not supported.\";\n        }\n        if (!Array.isArray(endpoints)) {\n            return [];\n        }\n        endpoints = Utils.deepClone(endpoints);\n        // convert v0.4 endpoints to v1.0\n        if (updatePaths) {\n            let isV04 = Versions.compare(version, \"0.4.x\", \"=\");\n            let isLtV100RC2 = Versions.compare(version, \"1.0.0-rc.2\", \"<\");\n\n            let addPutToPg = function(endpoints) {\n                let newPgPath = '/process_graphs/{process_graph_id}';\n                let i = endpoints.findIndex(e => e.path === newPgPath);\n                if (i >= 0) {\n                    if (endpoints[i].methods.indexOf('PUT') === -1) {\n                        endpoints[i].methods.push('PUT');\n                    }\n                }\n                else {\n                    endpoints.push({\n                        path: newPgPath,\n                        methods: ['PUT']\n                    });\n                }\n                return endpoints;\n            };\n\n            for(var i in endpoints) {\n                let e = endpoints[i];\n                if (isV04) {\n                    switch (e.path) {\n                        case '/output_formats':\n                            e.path = '/file_formats';\n                            break;\n                        case '/files/{user_id}':\n                            e.path = '/files';\n                            break;\n                        case '/files/{user_id}/{path}':\n                            e.path = '/files/{path}';\n                            break;\n                    }\n                }\n                if (isLtV100RC2) {\n                    switch (e.path) {\n                        case '/process_graphs':\n                            let post = e.methods.indexOf('POST');\n                            if (post >= 0) {\n                                e.methods.splice(post, 1);\n                                addPutToPg(endpoints);\n                            }\n                            break;\n                        case '/process_graphs/{process_graph_id}':\n                            let patch = e.methods.indexOf('PATCH');\n                            if (patch >= 0) {\n                                e.methods.splice(patch, 1);\n                                addPutToPg(endpoints);\n                            }\n                            break;\n                    }\n                }\n            }\n        }\n        return endpoints;\n    }\n\n    /**\n     * Alias for `convertFileFormatsToLatestSpec()`.\n     * \n     * @alias MigrateCapabilities.convertFileFormatsToLatestSpec\n     * @deprecated\n     * @param {object} formats - The response to convert\n     * @param {string} version - Version number of the API, which the response conforms to\n     * @returns {object}\n     */\n    static convertOutputFormatsToLatestSpec(formats, version) {\n        return this.convertFileFormatsToLatestSpec(formats, version);\n    }\n\n    /**\n     * Converts a `GET /file_formats` response to the latest version.\n     * \n     * Always returns a deep copy of the input object.\n     * \n     * @param {object} formats - The response to convert\n     * @param {string} version - Version number of the API, which the response conforms to\n     * @returns {object}\n     */\n    static convertFileFormatsToLatestSpec(formats, version) {\n        if (Versions.compare(version, \"0.3.x\", \"<=\")) {\n            throw \"Migrating from API version 0.3.0 and older is not supported.\";\n        }\n        if (Utils.isObject(formats)) {\n            formats = Utils.deepClone(formats);\n        }\n        else {\n            formats = {};\n        }\n\n        if (Versions.compare(version, \"0.4.x\", \"=\") && Utils.isObject(formats)) {\n            formats = {\n                output: formats\n            };\n        }\n\n        formats.input = upgradeFileFormats(formats.input, version);\n        formats.output = upgradeFileFormats(formats.output, version);\n\n        return formats;\n    }\n\n    /**\n     * Converts a `GET /service_types` response to the latest version.\n     * \n     * Always returns a deep copy of the input object.\n     * \n     * @param {object} types - The response to convert\n     * @param {string} version - Version number of the API, which the response conforms to\n     * @returns {object}\n     */\n    static convertServiceTypesToLatestSpec(types, version) {\n        if (Versions.compare(version, \"0.3.x\", \"<=\")) {\n            throw \"Migrating from API version 0.3.0 and older is not supported.\";\n        }\n        if (!Utils.isObject(types)) {\n            return {};\n        }\n\n        types = Utils.deepClone(types);\n        for(let t in types) {\n            if (!Utils.isObject(types[t])) {\n                types[t] = {};\n            }\n            if (Versions.compare(version, \"0.4.x\", \"=\")) {\n                // Remove attributes\n                delete types[t].attributes;\n\n                // Rename parameters to configuration\n                if (Utils.isObject(types[t].parameters)) {\n                    types[t].configuration = types[t].parameters;\n                }\n                delete types[t].parameters;\n\n                // Rename variables to process_parameters\n                if (Array.isArray(types[t].variables)) {\n                    types[t].process_parameters = types[t].variables.map(v => {\n                        let param = {\n                            name: v.variable_id,\n                            description: typeof v.description === 'string' ? v.description : \"\",\n                            schema: {\n                                type: [\n                                    typeof v.type === 'string' ? v.type : \"string\",\n                                    \"null\"\n                                ]\n                            }\n                        };\n                        if (typeof v.default !== 'undefined') {\n                            param.default = v.default;\n                        }\n                        return param;\n                    });\n                }\n                delete types[t].variables;\n            }\n\n            if (!Utils.isObject(types[t].configuration)) {\n                types[t].configuration = {};\n            }\n            else {\n                types[t].configuration = MigrateCommons.migrateDiscoveryParameters(types[t].configuration, version);\n            }\n\n            if (!Array.isArray(types[t].process_parameters)) {\n                types[t].process_parameters = [];\n            }\n\n            if (typeof types[t].links !== 'undefined') { // links not required, so only apply if defined anyway\n                types[t].links = MigrateCommons.migrateLinks(types[t].links, version);\n            }\n        }\n        return types;\n    }\n\n    /**\n     * Converts a `GET /udf_runtimes` response to the latest version.\n     * \n     * Always returns a deep copy of the input object.\n     * \n     * @param {object} runtimes - The response to convert\n     * @param {string} version - Version number of the API, which the response conforms to\n     * @returns {object}\n     */\n    static convertUdfRuntimesToLatestSpec(runtimes, version) {\n        if (Versions.compare(version, \"0.3.x\", \"<=\")) {\n            throw \"Migrating from API version 0.3.0 and older is not supported.\";\n        }\n        if (!Utils.isObject(runtimes)) {\n            return {};\n        }\n\n        runtimes = Utils.deepClone(runtimes);\n        for(let r in runtimes) {\n        // Nothing to do, was not supported in 0.3 and nothing changed in 0.4.\n            if (Versions.compare(version, \"0.4.x\", \"=\")) {\n                if (!Utils.isObject(runtimes[r])) {\n                    delete runtimes[r];\n                    continue;\n                }\n\n                // null is not allowed any longer, replace with empty string\n                if (runtimes[r].description === null) {\n                    runtimes[r].description = \"\";\n                }\n            }\n\n            if (typeof runtimes[r].type !== 'string') {\n                if (typeof runtimes[r].docker === 'string') {\n                    runtimes[r].type = 'docker';\n                }\n                else {\n                    runtimes[r].type = 'language';\n                }\n            }\n\n            if (typeof runtimes[r].links !== 'undefined') { // links not required, so only apply if defined anyway\n                runtimes[r].links = MigrateCommons.migrateLinks(runtimes[r].links, version);\n            }\n        }\n\n        return runtimes;\n    }\n\n}\n\nconst GIS_DATA_TYPES = ['raster', 'vector', 'table', 'other'];\n\nfunction upgradeFileFormats(formats, version) {\n    if (!Utils.isObject(formats)) {\n        formats = {};\n    }\n    for(let id in formats) {\n        if (!Utils.isObject(formats[id].parameters)) {\n            formats[id].parameters = {};\n        }\n        else {\n            formats[id].parameters = MigrateCommons.migrateDiscoveryParameters(formats[id].parameters, version);\n        }\n\n        // Can be empty: https://github.com/Open-EO/openeo-api/issues/325\n        if (!Array.isArray(formats[id].gis_data_types)) {\n            formats[id].gis_data_types = [];\n        }\n        else {\n            formats[id].gis_data_types = formats[id].gis_data_types.filter(t => GIS_DATA_TYPES.includes(t));\n        }\n\n        if (typeof formats[id].links !== 'undefined') { // links not required, so only apply if defined anyway\n            formats[id].links = MigrateCommons.migrateLinks(formats[id].links, version);\n        }\n    }\n    return formats;\n}\n\nmodule.exports = MigrateCapabilities;","'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n  var envHasBigInt64Array = typeof BigInt64Array !== 'undefined';\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n    if ((a instanceof Map) && (b instanceof Map)) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries())\n        if (!b.has(i[0])) return false;\n      for (i of a.entries())\n        if (!equal(i[1], b.get(i[0]))) return false;\n      return true;\n    }\n\n    if ((a instanceof Set) && (b instanceof Set)) {\n      if (a.size !== b.size) return false;\n      for (i of a.entries())\n        if (!b.has(i[0])) return false;\n      return true;\n    }\n\n    if (ArrayBuffer.isView(a) && ArrayBuffer.isView(b)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (a[i] !== b[i]) return false;\n      return true;\n    }\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n","export const semver = /^[v^~<>=]*?(\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+)(?:\\.([x*]|\\d+))?(?:-([\\da-z\\-]+(?:\\.[\\da-z\\-]+)*))?(?:\\+[\\da-z\\-]+(?:\\.[\\da-z\\-]+)*)?)?)?$/i;\nexport const validateAndParse = (version) => {\n    if (typeof version !== 'string') {\n        throw new TypeError('Invalid argument expected string');\n    }\n    const match = version.match(semver);\n    if (!match) {\n        throw new Error(`Invalid argument not valid semver ('${version}' received)`);\n    }\n    match.shift();\n    return match;\n};\nconst isWildcard = (s) => s === '*' || s === 'x' || s === 'X';\nconst tryParse = (v) => {\n    const n = parseInt(v, 10);\n    return isNaN(n) ? v : n;\n};\nconst forceType = (a, b) => typeof a !== typeof b ? [String(a), String(b)] : [a, b];\nconst compareStrings = (a, b) => {\n    if (isWildcard(a) || isWildcard(b))\n        return 0;\n    const [ap, bp] = forceType(tryParse(a), tryParse(b));\n    if (ap > bp)\n        return 1;\n    if (ap < bp)\n        return -1;\n    return 0;\n};\nexport const compareSegments = (a, b) => {\n    for (let i = 0; i < Math.max(a.length, b.length); i++) {\n        const r = compareStrings(a[i] || '0', b[i] || '0');\n        if (r !== 0)\n            return r;\n    }\n    return 0;\n};\n//# sourceMappingURL=utils.js.map","import { compareSegments, validateAndParse } from './utils.js';\n/**\n * Compare [semver](https://semver.org/) version strings to find greater, equal or lesser.\n * This library supports the full semver specification, including comparing versions with different number of digits like `1.0.0`, `1.0`, `1`, and pre-release versions like `1.0.0-alpha`.\n * @param v1 - First version to compare\n * @param v2 - Second version to compare\n * @returns Numeric value compatible with the [Array.sort(fn) interface](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#Parameters).\n */\nexport const compareVersions = (v1, v2) => {\n    // validate input and split into segments\n    const n1 = validateAndParse(v1);\n    const n2 = validateAndParse(v2);\n    // pop off the patch\n    const p1 = n1.pop();\n    const p2 = n2.pop();\n    // validate numbers\n    const r = compareSegments(n1, n2);\n    if (r !== 0)\n        return r;\n    // validate pre-release\n    if (p1 && p2) {\n        return compareSegments(p1.split('.'), p2.split('.'));\n    }\n    else if (p1 || p2) {\n        return p1 ? -1 : 1;\n    }\n    return 0;\n};\n//# sourceMappingURL=compareVersions.js.map","import { compareVersions } from './compareVersions.js';\n/**\n * Compare [semver](https://semver.org/) version strings using the specified operator.\n *\n * @param v1 First version to compare\n * @param v2 Second version to compare\n * @param operator Allowed arithmetic operator to use\n * @returns `true` if the comparison between the firstVersion and the secondVersion satisfies the operator, `false` otherwise.\n *\n * @example\n * ```\n * compare('10.1.8', '10.0.4', '>'); // return true\n * compare('10.0.1', '10.0.1', '='); // return true\n * compare('10.1.1', '10.2.2', '<'); // return true\n * compare('10.1.1', '10.2.2', '<='); // return true\n * compare('10.1.1', '10.2.2', '>='); // return false\n * ```\n */\nexport const compare = (v1, v2, operator) => {\n    // validate input operator\n    assertValidOperator(operator);\n    // since result of compareVersions can only be -1 or 0 or 1\n    // a simple map can be used to replace switch\n    const res = compareVersions(v1, v2);\n    return operatorResMap[operator].includes(res);\n};\nconst operatorResMap = {\n    '>': [1],\n    '>=': [0, 1],\n    '=': [0],\n    '<=': [-1, 0],\n    '<': [-1],\n    '!=': [-1, 1],\n};\nconst allowedOperators = Object.keys(operatorResMap);\nconst assertValidOperator = (op) => {\n    if (typeof op !== 'string') {\n        throw new TypeError(`Invalid operator type, expected string but got ${typeof op}`);\n    }\n    if (allowedOperators.indexOf(op) === -1) {\n        throw new Error(`Invalid operator, expected one of ${allowedOperators.join('|')}`);\n    }\n};\n//# sourceMappingURL=compare.js.map","import { compare } from './compare.js';\nimport { compareSegments, validateAndParse } from './utils.js';\n/**\n * Match [npm semver](https://docs.npmjs.com/cli/v6/using-npm/semver) version range.\n *\n * @param version Version number to match\n * @param range Range pattern for version\n * @returns `true` if the version number is within the range, `false` otherwise.\n *\n * @example\n * ```\n * satisfies('1.1.0', '^1.0.0'); // return true\n * satisfies('1.1.0', '~1.0.0'); // return false\n * ```\n */\nexport const satisfies = (version, range) => {\n    // clean input\n    range = range.replace(/([><=]+)\\s+/g, '$1');\n    // handle multiple comparators\n    if (range.includes('||')) {\n        return range.split('||').some((r) => satisfies(version, r));\n    }\n    else if (range.includes(' - ')) {\n        const [a, b] = range.split(' - ', 2);\n        return satisfies(version, `>=${a} <=${b}`);\n    }\n    else if (range.includes(' ')) {\n        return range\n            .trim()\n            .replace(/\\s{2,}/g, ' ')\n            .split(' ')\n            .every((r) => satisfies(version, r));\n    }\n    // if no range operator then \"=\"\n    const m = range.match(/^([<>=~^]+)/);\n    const op = m ? m[1] : '=';\n    // if gt/lt/eq then operator compare\n    if (op !== '^' && op !== '~')\n        return compare(version, range, op);\n    // else range of either \"~\" or \"^\" is assumed\n    const [v1, v2, v3, , vp] = validateAndParse(version);\n    const [r1, r2, r3, , rp] = validateAndParse(range);\n    const v = [v1, v2, v3];\n    const r = [r1, r2 !== null && r2 !== void 0 ? r2 : 'x', r3 !== null && r3 !== void 0 ? r3 : 'x'];\n    // validate pre-release\n    if (rp) {\n        if (!vp)\n            return false;\n        if (compareSegments(v, r) !== 0)\n            return false;\n        if (compareSegments(vp.split('.'), rp.split('.')) === -1)\n            return false;\n    }\n    // first non-zero number\n    const nonZero = r.findIndex((v) => v !== '0') + 1;\n    // pointer to where segments can be >=\n    const i = op === '~' ? 2 : nonZero > 1 ? nonZero : 1;\n    // before pointer must be equal\n    if (compareSegments(v.slice(0, i), r.slice(0, i)) !== 0)\n        return false;\n    // after pointer must be >=\n    if (compareSegments(v.slice(i), r.slice(i)) === -1)\n        return false;\n    return true;\n};\n//# sourceMappingURL=satisfies.js.map","import { semver } from './utils.js';\n/**\n * Validate [semver](https://semver.org/) version strings.\n *\n * @param version Version number to validate\n * @returns `true` if the version number is a valid semver version number, `false` otherwise.\n *\n * @example\n * ```\n * validate('1.0.0-rc.1'); // return true\n * validate('1.0-rc.1'); // return false\n * validate('foo'); // return false\n * ```\n */\nexport const validate = (version) => typeof version === 'string' && /^[v\\d]/.test(version) && semver.test(version);\n/**\n * Validate [semver](https://semver.org/) version strings strictly. Will not accept wildcards and version ranges.\n *\n * @param version Version number to validate\n * @returns `true` if the version number is a valid semver version number `false` otherwise\n *\n * @example\n * ```\n * validate('1.0.0-rc.1'); // return true\n * validate('1.0-rc.1'); // return false\n * validate('foo'); // return false\n * ```\n */\nexport const validateStrict = (version) => typeof version === 'string' &&\n    /^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$/.test(version);\n//# sourceMappingURL=validate.js.map","export { compare } from './compare.js';\nexport { compareVersions } from './compareVersions.js';\nexport { satisfies } from './satisfies.js';\nexport { validate, validateStrict } from './validate.js';\n//# sourceMappingURL=index.js.map","/**\n * Translates the list format produced by css-loader into something\n * easier to manipulate.\n */\nexport default function listToStyles (parentId, list) {\n  var styles = []\n  var newStyles = {}\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i]\n    var id = item[0]\n    var css = item[1]\n    var media = item[2]\n    var sourceMap = item[3]\n    var part = {\n      id: parentId + ':' + i,\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    }\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = { id: id, parts: [part] })\n    } else {\n      newStyles[id].parts.push(part)\n    }\n  }\n  return styles\n}\n","import listToStyles from './listToStyles'\n\nexport default function addStylesToShadowDOM (parentId, list, shadowRoot) {\n  var styles = listToStyles(parentId, list)\n  addStyles(styles, shadowRoot)\n}\n\n/*\ntype StyleObject = {\n  id: number;\n  parts: Array<StyleObjectPart>\n}\n\ntype StyleObjectPart = {\n  css: string;\n  media: string;\n  sourceMap: ?string\n}\n*/\n\nfunction addStyles (styles /* Array<StyleObject> */, shadowRoot) {\n  const injectedStyles =\n    shadowRoot._injectedStyles ||\n    (shadowRoot._injectedStyles = {})\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i]\n    var style = injectedStyles[item.id]\n    if (!style) {\n      for (var j = 0; j < item.parts.length; j++) {\n        addStyle(item.parts[j], shadowRoot)\n      }\n      injectedStyles[item.id] = true\n    }\n  }\n}\n\nfunction createStyleElement (shadowRoot) {\n  var styleElement = document.createElement('style')\n  styleElement.type = 'text/css'\n  shadowRoot.appendChild(styleElement)\n  return styleElement\n}\n\nfunction addStyle (obj /* StyleObjectPart */, shadowRoot) {\n  var styleElement = createStyleElement(shadowRoot)\n  var css = obj.css\n  var media = obj.media\n  var sourceMap = obj.sourceMap\n\n  if (media) {\n    styleElement.setAttribute('media', media)\n  }\n\n  if (sourceMap) {\n    // https://developer.chrome.com/devtools/docs/javascript-debugging\n    // this makes source maps inside style tags work properly in Chrome\n    css += '\\n/*# sourceURL=' + sourceMap.sources[0] + ' */'\n    // http://stackoverflow.com/a/26603875\n    css += '\\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'\n  }\n\n  if (styleElement.styleSheet) {\n    styleElement.styleSheet.cssText = css\n  } else {\n    while (styleElement.firstChild) {\n      styleElement.removeChild(styleElement.firstChild)\n    }\n    styleElement.appendChild(document.createTextNode(css))\n  }\n}\n"],"names":[],"sourceRoot":""}