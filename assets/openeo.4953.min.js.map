{"version":3,"file":"openeo.4953.min.js","mappings":"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","sources":["webpack://vue-lib-openeo/./components/ModelBuilder.vue?b128","webpack://vue-lib-openeo/./components/ModelBuilder.vue","webpack://vue-lib-openeo/components/ModelBuilder.vue","webpack://vue-lib-openeo/./components/ModelBuilder.vue?5e79","webpack://vue-lib-openeo/./components/ModelBuilder.vue?292a","webpack://vue-lib-openeo/./components/ModelBuilder.vue?e74f"],"sourcesContent":["// style-loader: Adds some css to the DOM by adding a <style> tag\n\n// load the styles\nvar content = require(\"!!../node_modules/css-loader/dist/cjs.js??clonedRuleSet-64.use[1]!../node_modules/@vue/vue-loader-v15/lib/loaders/stylePostLoader.js!../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-64.use[2]!../node_modules/postcss-loader/dist/cjs.js??clonedRuleSet-64.use[3]!../node_modules/sass-loader/dist/cjs.js??clonedRuleSet-64.use[4]!../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./ModelBuilder.vue?vue&type=style&index=0&id=cfd84820&prod&lang=scss&shadow\");\nif(content.__esModule) content = content.default;\nif(typeof content === 'string') content = [[module.id, content, '']];\nif(content.locals) module.exports = content.locals;\n// add CSS to Shadow Root\nvar add = require(\"!../node_modules/vue-style-loader/lib/addStylesShadow.js\").default\nmodule.exports.__inject__ = function (shadowRoot) {\n  add(\"4e1b47aa\", content, shadowRoot)\n};","var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',{ref:\"div\",class:_vm.classes,style:(_vm.style),attrs:{\"id\":_vm.id,\"tabindex\":\"0\"},on:{\"mousemove\":_vm.onMouseMove,\"mousedown\":_vm.onMouseDown,\"wheel\":_vm.onMouseWheel,\"keydown\":_vm.onKeyDown,\"focus\":function($event){_vm.hasFocus = true},\"blur\":function($event){_vm.hasFocus = false}}},[_c('svg',{staticClass:\"canvas\",attrs:{\"xmlns\":\"http://www.w3.org/2000/svg\",\"version\":\"1.1\"}},[_vm._l((_vm.edges),function(edge){return _c('Edge',{key:edge.id,attrs:{\"id\":edge.id,\"parameter1\":edge.parameter1,\"parameter2\":edge.parameter2,\"selected\":edge.selected,\"inactive\":edge.inactive,\"issues\":edge.issues,\"state\":_vm.state},on:{\"mounted\":node => _vm.mount(edge, node),\"unmounted\":() => _vm.mount(edge),\"position\":function($event){return _vm.updateEdgePos(edge, arguments)}}})}),_vm._l((_vm.hiddenParameterRefEdges),function(edge){return _c('Edge',{key:edge.id,attrs:{\"id\":edge.id,\"parameter1\":edge.parameter1,\"parameter2\":edge.parameter2,\"inactive\":true,\"lineColor\":[200,200,200,1],\"lineWidth\":2,\"state\":_vm.state},on:{\"mounted\":node => _vm.mount(edge, node),\"unmounted\":() => _vm.mount(edge)}})}),(_vm.linkingLine)?_c('line',_vm._b({},'line',_vm.linkingLine,false)):_vm._e(),(_vm.selectRect)?_c('rect',_vm._b({},'rect',_vm.selectRect,false)):_vm._e()],2),_c('div',{staticClass:\"blocks\"},_vm._l((_vm.blocks),function(block){return _c('Block',{key:block.id,attrs:{\"id\":block.id,\"type\":block.type,\"spec\":block.spec,\"state\":_vm.state,\"selected\":block.selected,\"position\":block.position,\"origin\":block.origin,\"process_id\":block.process_id,\"namespace\":block.namespace,\"result\":block.result,\"args\":block.arguments,\"description\":block.description},on:{\"update\":(...args) => _vm.updateBlock(block, ...args),\"mounted\":node => _vm.mount(block, node),\"unmounted\":() => _vm.mount(block),\"move\":_vm.startDragBlock}})}),1),(_vm.state.scale < 0.7 || _vm.showZoomInfo)?_c('div',{staticClass:\"zoomInfo\"},[(_vm.state.scale < 0.7)?_c('div',[_vm._v(\" Zoom in for more details. \")]):_vm._e(),(_vm.showZoomInfo)?_c('div',[_vm._v(\" Zoom with \"),_c('kbd',[_vm._v(\"STRG\")]),_vm._v(\" or \"),_c('kbd',[_vm._v(\"Meta\")]),_vm._v(\" key and the mouse wheel. \")]):_vm._e()]):_vm._e(),(_vm.parameterViewer)?_c('ParameterViewer',_vm._b({on:{\"close\":function($event){_vm.parameterViewer = null}}},'ParameterViewer',_vm.parameterViewer,false)):_vm._e()],1)\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","<template>\n    <div ref=\"div\" :id=\"id\" :class=\"classes\" tabindex=\"0\" :style=\"style\"\n        @mousemove=\"onMouseMove\"\n        @mousedown=\"onMouseDown\"\n        @wheel=\"onMouseWheel\"\n        @keydown=\"onKeyDown\"\n        @focus=\"hasFocus = true\"\n        @blur=\"hasFocus = false\">\n        <!-- tabindex is to allow focus for delete keystroke etc -->\n        <svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" class=\"canvas\">\n            <Edge v-for=\"edge in edges\" :key=\"edge.id\" :id=\"edge.id\"\n                :parameter1=\"edge.parameter1\" :parameter2=\"edge.parameter2\"\n                :selected=\"edge.selected\" :inactive=\"edge.inactive\" :issues=\"edge.issues\" :state=\"state\"\n                @mounted=\"node => mount(edge, node)\" @unmounted=\"() => mount(edge)\"\n                @position=\"updateEdgePos(edge, arguments)\" />\n            <Edge v-for=\"edge in hiddenParameterRefEdges\" :key=\"edge.id\" :id=\"edge.id\"\n                :parameter1=\"edge.parameter1\" :parameter2=\"edge.parameter2\"\n                @mounted=\"node => mount(edge, node)\" @unmounted=\"() => mount(edge)\"\n                :inactive=\"true\" :lineColor=\"[200,200,200,1]\" :lineWidth=\"2\" :state=\"state\" />\n            <line v-if=\"linkingLine\" v-bind=\"linkingLine\" />\n            <rect v-if=\"selectRect\" v-bind=\"selectRect\" />\n        </svg>\n        <div class=\"blocks\">\n            <Block v-for=\"(block) in blocks\" :key=\"block.id\"\n                :id=\"block.id\" :type=\"block.type\" :spec=\"block.spec\" :state=\"state\"\n                :selected=\"block.selected\" :position=\"block.position\" :origin=\"block.origin\"\n                :process_id=\"block.process_id\" :namespace=\"block.namespace\" :result=\"block.result\" :args=\"block.arguments\" :description=\"block.description\" \n                @update=\"(...args) => updateBlock(block, ...args)\"\n                @mounted=\"node => mount(block, node)\" @unmounted=\"() => mount(block)\"\n                @move=\"startDragBlock\" />\n        </div>\n        <div v-if=\"state.scale < 0.7 || showZoomInfo\" class=\"zoomInfo\">\n            <div v-if=\"state.scale < 0.7\">\n                Zoom in for more details.\n            </div>\n            <div v-if=\"showZoomInfo\">\n                Zoom with <kbd>STRG</kbd> or <kbd>Meta</kbd> key and the mouse wheel.\n            </div>\n        </div>\n        <ParameterViewer v-if=\"parameterViewer\" v-bind=\"parameterViewer\" @close=\"parameterViewer = null\" />\n    </div>\n</template>\n\n<script>\nimport Block from './model-builder/Block.vue';\nimport Edge from './model-builder/Edge.vue';\nimport Utils from '../utils.js';\nimport { ProcessRegistry } from '@openeo/js-commons';\nimport { JsonSchemaValidator, ProcessGraph, Utils as PgUtils } from '@openeo/js-processgraphs';\nimport Vue from 'vue';\nimport boxIntersectsBox from 'intersects/box-box';\nimport boxIntersectsLine from 'intersects/box-line';\nimport Config from './model-builder/config.js';\n\nconst getDefaultState = function(blocks) {\n    return Vue.observable({\n        root: blocks,\n        editable: false,\n        compactMode: false,\n        moving: null, // Is the user dragging the view?\n        selecting: null, // Is the user multi-selecting?\n        center: [0,0],\n        mouse: [0,0],\n        scale: Config.defaultScale,\n        linkFrom: null, // Array\n        linkTo: null // Array\n    });\n};\nconst MARGIN = 20;\n\nconst selectionChangeWatcher = function (newVal, oldVal) {\n    if (!Array.isArray(newVal) || !Array.isArray(oldVal) || newVal.length !== oldVal.length || !newVal.every((value,i) => value.id === oldVal[i].id)) {\n        this.$emit('selectionChanged', this.selectedBlocks, this.selectedEdges);\n    }\n};\n\nexport default {\n    name: 'ModelBuilder',\n    components: {\n        Block,\n        Edge,\n        ParameterViewer: () => import('./model-builder/ParameterViewer.vue')\n    },\n    props: {\n        id: {\n            type: String,\n            required: true\n        },\n        editable: {\n            type: Boolean,\n            default: false\n        },\n        value: {\n            type: Object,\n            default: () => ({})\n        },\n        collections: {\n            type: Array,\n            default: () => []\n        },\n        processes: {\n            type: [Array, Object],\n            default: () => []\n        },\n\t\tparent: {\n\t\t\ttype: Object,\n\t\t\tdefault: null\n\t\t},\n\t\tparentSchema: {\n\t\t\ttype: Object,\n\t\t\tdefault: null\n\t\t},\n        historySize: {\n            type: Number,\n            default: 30\n        },\n        explicitZoom: {\n            type: Boolean,\n            default: false\n        },\n        height: {\n            type: String,\n            default: null\n        }\n    },\n    data() {\n        return {\n            isMounted: false,\n            allMounted: false,\n\n            // Current offset for block that are generated without specific coordinates so that not all block occur on the same position\n            newBlockOffset: 0,\n\n            // History\n            history: [],\n            historyPointer: null,\n\n            process: Object.freeze(this.value),\n            // Metadata for blocks to show\n            blocks: [],\n            // Metadata for edges to show\n            edges: [],\n            hiddenParameterRefEdges: {},\n\n            processGraph: null,\n\n            // Next block id\n            nextBlockId: 1,\n            // Next edge id\n            nextEdgeId: 1,\n            // Copy&Paste\n            clipboard: null,\n\n            activeTransactions: 0,\n            hasFocus: false,\n            linkingLine: null,\n            parameterViewer: null,\n\n            showZoomInfo: this.explicitZoom,\n            \n            // State specific to this blocks instance including all children\n            state: getDefaultState(this)\n        };\n    },\n    computed: {\n        style() {\n            let style = {};\n            if (typeof this.height === 'string') {\n                style.height = this.height;\n            }\n            return style;\n        },\n        classes() {\n            let classes = [\n                'vue-component',\n                'model-builder'\n            ];\n            if (this.hasFocus) {\n                classes.push('focus');\n            }\n            if (this.editable) {\n                classes.push('editable');\n            }\n\n            if (this.state.compactMode) {\n                classes.push('compact');\n            }\n\n            if (this.state.scale < 0.5) {\n                classes.push('scale_xs');\n            }\n            else if (this.state.scale < 0.7) {\n                classes.push('scale_s');\n            }\n            else if (this.state.scale < 0.9) {\n                classes.push('scale_m');\n            }\n            else if (this.state.scale < 1.1) {\n                classes.push('scale_l');\n            }\n            else {\n                classes.push('scale_xl');\n            }\n\n            return classes;\n        },\n        selectRect() {\n            if (!this.state.selecting) {\n                return null;\n            }\n            return {\n                x: Math.min(this.state.selecting.current[0], this.state.selecting.start[0]),\n                y: Math.min(this.state.selecting.current[1], this.state.selecting.start[1]),\n                width: Math.abs(this.state.selecting.current[0] - this.state.selecting.start[0]),\n                height: Math.abs(this.state.selecting.current[1] - this.state.selecting.start[1]),\n                'stroke': 'rgba(0,0,0,0.8)',\n                'stroke-width': 1,\n                'fill': 'rgba(0,0,0,0.05)'\n            };\n        },\n        processRegistry() {\n            // If I link between openeo-web-editor and openeo-vue-components, instanceof ProcessRegistry fails.\n            // Webpack seems to mangle names and thus I need to check for specific processes alternatively to detect whether this could be a ProcessRegistry.\n            if (this.processes instanceof ProcessRegistry || (typeof this.processes.count === 'function' && typeof this.processes.get === 'function')) {\n                return this.processes;\n            }\n            else if (Array.isArray(this.processes)) {\n                return new ProcessRegistry(this.processes);\n            }\n            else {\n                throw new Error('Invalid processes specified, must be ProcessRegistry or Array');\n            }\n        },\n        hasProcesses() {\n            return this.processRegistry.count() > 0;\n        },\n        processBlocks() {\n            return this.blocks.filter(b => b.type === 'process');\n        },\n        selectedBlocks() {\n            return this.blocks.filter(block => block.selected);\n        },\n        selectedEdges() {\n            return this.edges.filter(edge => edge.selected);\n        },\n        selectedSideEdge() {\n            if (this.selectedEdges.length === 1 && this.selectedEdges[0].selectedParameter) {\n                return this.selectedEdges[0];\n            }\n            return null;\n        },\n        hasSelection() {\n            return this.selectedBlocks.length > 0 || this.selectedEdges.length > 0;\n        },\n        processParametersFromSchemas() {\n            // Get all process parameters from the parent process\n            // this.parent.$parent => ModelBuilder instance\n\t\t\tlet parentParams = [];\n\t\t\tif (this.parent && this.parent.$parent && typeof this.parent.$parent.getPgParameters === 'function') {\n\t\t\t\tparentParams = this.parent.$parent.getPgParameters().map(block => block.spec);\n\t\t\t}\n\n            let callbackParams = [];\n            // If we have a parameter schema given, go through the parameter schema and get the available process parameters from there.\n            if (this.parentSchema) {\n\t\t\t    callbackParams = this.parentSchema.getCallbackParameters();\n            }\n\n            // Remove all parameters from the parent that are overridden by the more specific parameters.\n            let filteredParentParams = parentParams.filter(p1 => !callbackParams.find(p2 => p1.name === p2.name));\n            // Add the filtered parameters from the parent to the more specific parameters\n            return callbackParams.concat(filteredParentParams);\n        }\n    },\n    watch: {\n        parentSchema() {\n            this.importPgParameters(this.processParametersFromSchemas, 'schema');\n        },\n        async value(value) {\n            // Only run if component has been mounted\n            if (!this.allMounted) {\n                return;\n            }\n\n            // Only import when user changes data (i.e. not a BlocksProcess exported from export())\n            if (!(value instanceof BlocksProcess)) {\n                this.process = value;\n                await this.import(value, { propagate: false, undoOnError: false }); // don't propagate, otherwise results in an infinite loop\n            }\n        },\n        editable: {\n            immediate: true,\n            handler(editable) {\n                this.state.editable = editable;\n            }\n        },\n        selectedEdges: selectionChangeWatcher,\n        selectedBlocks: selectionChangeWatcher,\n        allMounted() {\n            this.updateHiddenParameterRefEdges();\n        },\n        isMounted() {\n            this.checkAllMounted();\n        }\n    },\n\tbeforeCreate() {\n\t\tUtils.enableHtmlProps(this);\n\t},\n    async created() {\n        if (!this.supports('error')) {\n            // Print error to console if event is not supported by implementing context\n            this.$on('error', (msg, title = null) => console.error(msg, title));\n        }\n        if (!this.supports('editArguments')) {\n            this.$on('editArguments', (...args) => this.showParameterViewer(...args));\n        }\n        this.$on('duplicate', this.duplicate.bind(this));\n    },\n    async mounted() {\n        Utils.loadFontAwesome(this);\n\n        // Setting up default viewer center\n        this.moveCenter(0, 0, true);\n\n        // ToDo: Replace with mouseleave?\n        this.onDocumentMouseUpFn = this.onDocumentMouseUp.bind(this)\n        document.addEventListener('mouseup', this.onDocumentMouseUpFn);\n\n        await this.importPgParameters(this.processParametersFromSchemas, 'schema');\n        if (!await this.import(this.value, { propagate: false, undoOnError: false })) {\n            this.perfectScale();\n        }\n        selectionChangeWatcher.bind(this)();\n\n        this.isMounted = true;\n    },\n    beforeDestroy() {\n        document.removeEventListener('mouseup', this.onDocumentMouseUpFn);\n    },\n    methods: {\n        updateEdgePos(edge, pos) {\n            edge.position1 = pos[0];\n            edge.position2 = pos[1];\n        },\n        mount(elem, node = null) {\n            elem.$el = node;\n            this.checkAllMounted();\n        },\n        checkAllMounted() {\n            if (!this.isMounted) {\n                this.allMounted = false;\n            }\n            else {\n                this.allMounted = !this.blocks.find(block => !block.$el) || !this.edges.find(edge => !edge.$el);\n            }\n        },\n        updateBlockArguments(block, args, removedParams) {\n            if (removedParams.length > 0) {\n                this.parameterRemoved(block, removedParams);\n            }\n            this.$set(block, 'arguments', args);\n            this.commit();\n            if(removedParams.length > 0) {\n                this.$nextTick(() => this.refreshEdges());\n            }\n        },\n        updateBlockDescription(block, description) {\n            this.$set(block, 'description', description);\n            this.commit();\n        },\n        updateBlockPos(block, pos, saveHistory = true) {\n            this.$set(block, 'position', pos);\n            this.commit(null, saveHistory, false);\n        },\n        updateBlockResult(block, result) {\n            this.$set(block, 'result', result);\n            this.commit();\n        },\n        updateBlockSelected(block, selected, unselectOthers = true) {\n            if (unselectOthers) {\n                this.unselectAll();\n            }\n            this.$set(block, 'selected', selected);\n            this.commit(null, false, false);\n        },\n        updateBlockSpec(block, data) {\n            let parameterFields = ['name', 'schema', 'description', 'optional', 'deprecated', 'experimental', 'default'];\n            let newBlock = Utils.omitFromObject(block.spec, parameterFields);\n            Object.assign(newBlock, data);\n            // Remove default values (and unset default value if parameter is required)\n            if (!newBlock.optional) {\n                delete newBlock.optional;\n                delete newBlock.default;\n            }\n            if (!newBlock.deprecated) {\n                delete newBlock.deprecated;\n            }\n            if (!newBlock.experimental) {\n                delete newBlock.experimental;\n            }\n            this.$set(block, 'spec', newBlock);\n            this.commit();\n        },\n        updateBlock(block, key, value, extra) {\n            switch(key) {\n                case 'arguments':\n                    this.updateBlockArguments(block, value, extra);\n                    break;\n                case 'description':\n                    this.updateBlockDescription(block, value);\n                    break;\n                case 'position':\n                    this.updateBlockPos(block, value, extra);\n                    break;\n                case 'result':\n                    this.setResultNode(block, value);\n                    break;\n                case 'selected':\n                    this.updateBlockSelected(block, value, extra);\n                    break;\n                case 'spec':\n                    this.updateBlockSpec(block, value);\n                    break;\n            }\n        },\n        updateHiddenParameterRefEdges() {\n            // We can only reliably detect parameter refs if we know which parameters a process makes available to the child process\n            // So if we don't have process schemas, don't offer this functionality.\n            // Also don't execute (yet) if no parameters are given or not all elements are mounted yet.\n            if (!this.hasProcesses || !this.allMounted || !this.blocks.find(block => block.type === 'parameter')) {\n                this.hiddenParameterRefEdges = {};\n                return;\n            }\n\n            let hiddenRefs = {};\n            for(let process of this.processBlocks) {\n                for (let argName in process.arguments) {\n                    let value = process.arguments[argName];\n                    if (!Utils.isObject(value) || !Utils.isObject(value.process_graph)) {\n                        continue; // Process can only have hidden refs it it contains a process graph\n                    }\n                    \n                    let refs = PgUtils.getRefs(value, true, true).filter(ref => typeof ref.from_parameter !== 'undefined');\n                    for(let ref of refs) {\n                        try {\n                            if(!process.$el) {\n                                continue;\n                            }\n                            if (process.$el.isParameterScoped(argName, ref.from_parameter)) {\n                                continue; // Skip if the parameter usage is scoped (i.e. defined as process parameetr for the children)\n                            }\n                            let parameter = this.getPgParameterById('$' + ref.from_parameter);\n                            if (!parameter) {\n                                continue; // Skip if parameter can't be found\n                            }\n                            let parameter1 = parameter.$el.getBlockParameter('output');\n                            let parameter2 = process.$el.getBlockParameter(argName);\n                            let id = `${parameter.id}->${process.id}:${argName}`;\n                            if (parameter1 && parameter2) {\n                                if (this.hiddenParameterRefEdges[id]) {\n                                    hiddenRefs[id] = this.hiddenParameterRefEdges[id];\n                                }\n                                else {\n                                    hiddenRefs[id] = {\n                                        $el: null,\n                                        id,\n                                        parameter1,\n                                        parameter2\n                                    };\n                                }\n                            }\n                        } catch(error) {\n                             console.warn(error);\n                        }\n                    }\n                }\n\n            }\n            this.hiddenParameterRefEdges = hiddenRefs;\n        },\n        parameterRemoved(block, parameterNames) {\n            for(let edge of this.edges.slice(0)) {\n                if(edge.parameter2.$parent.id === block.id && parameterNames.includes(edge.parameter2.name)) {\n                    this.removeEdge(edge);\n                }\n            }\n        },\n        startDragBlock(event) {\n            for(let block of this.blocks) {\n                if (block.$el) {\n                    block.$el.startDrag(event);\n                }\n            }\n        },\n        refreshEdges() {\n            this.refreshEdgesFor(this.edges);\n            this.refreshEdgesFor(Object.values(this.hiddenParameterRefEdges));\n        },\n        refreshEdgesFor(edges) {\n            for(let edge of edges) {\n                if (edge.$el) {\n                    edge.$el.updatePositions();\n                }\n            }\n        },\n        supports(event) {\n            return Boolean(this.$listeners && this.$listeners[event]);\n        },\n        focus() {\n            this.$refs.div.focus();\n        },\n        link(parameter) {\n            if (this.state.linkFrom) {\n                this.state.linkTo = parameter;\n            }\n            else {\n                this.state.linkFrom = parameter;\n            }\n        },\n        unlink(parameter = null) {\n            if (parameter) {\n                if (this.state.linkTo == parameter) {\n                    this.state.linkTo = null;\n                }\n                else if (this.state.linkFrom == parameter) {\n                    this.state.linkFrom = null;\n                    this.linkingLine = null;\n                }\n            }\n            else {\n                this.state.linkTo = null;\n                this.state.linkFrom = null;\n                this.linkingLine = null;\n            }\n        },\n        multiSelect() {\n            let box = this.selectRect;\n            this.blocks\n                .filter(b => {\n                    if (Array.isArray(b.position) && b.$el) {\n                        let pos = b.$el.getDimensions();\n                        return boxIntersectsBox(box.x, box.y, box.width, box.height, pos.x, pos.y, pos.width, pos.height);\n                    }\n                    return false;\n                })\n                .map(b => b.selected = true);\n            this.edges\n                .filter(e => Array.isArray(e.position1) && Array.isArray(e.position2) && boxIntersectsLine(box.x, box.y, box.width, box.height, e.position1[0], e.position1[1], e.position2[0], e.position2[1]))\n                .map(e => e.selected = true);\n        },\n        toJSON() {\n            let process = this.export();\n            return JSON.stringify(process, null, 2);\n        },\n        async onDocumentMouseUp(event) {\n            if (this.parameterViewer) {\n                return;\n            }\n            if (this.selectedSideEdge) {\n                this.selectEdge(this.selectedSideEdge, null); // Reset selectedParameter, but don't change selected state.\n            }\n            if (this.state.selecting) {\n                this.multiSelect();\n                this.state.selecting = null;\n            }\n            if (this.state.moving) {\n                this.state.moving = null;\n            }\n            if (this.state.editable && this.state.linkFrom) {\n                if (event.which == 1 && this.state.linkTo) {\n                    try {\n                        await this.addEdge(this.state.linkFrom, this.state.linkTo);\n                    } catch (error) {\n                        this.$emit(\"error\", error);\n                    }\n                }\n                this.unlink();\n            }\n        },\n        async onKeyDown(event) {\n            if (this.parameterViewer) {\n                return;\n            }\n            var allInputs = document.querySelectorAll('input, textarea, button, select, datalist');\n            for(let el of allInputs) {\n                if (el === document.activeElement) {\n                    return;\n                }\n            }\n\n            let captured = false;\n            if (this.state.editable) {\n                // delete selected blocks/edges\n                if (event.code === 'Delete') {\n                    this.deleteSelected();\n                    captured = true;\n                }\n                else if (event.ctrlKey || event.metaKey) { // STRG for Win/Linux, meta/cmd from Mac\n                    if (event.code === 'KeyV') {\n                        if (!navigator || !navigator.clipboard || typeof navigator.clipboard.readText !== 'function') {\n                            this.$emit('error', 'Pasting is not supported by your browser.');\n                            return;\n                        }\n                        if (this.hasSelection && this.clipboard) {\n                            if (this.clipboard.edges.length > 0) {\n                                this.$emit('error', 'Pasting edges is not supported yet.');\n                                return;\n                            }\n                            if (this.clipboard.blocks.length > 0) {\n                                this.clipboard.blocks.forEach(block => {\n                                    if (block.type === 'process' && block.origin !== 'schema') {\n                                        this.duplicate(Utils.pickFromObject(block, [\"arguments\", \"description\", \"namespace\", \"position\", \"process_id\"]));\n                                    }\n                                    else {\n                                        this.$emit('error', `Pasting block '${block.id}' is not supported.`);\n                                    }\n                                });\n                            }\n                        }\n                        else {\n                            try {\n                                const text = await navigator.clipboard.readText();\n                                let process = JSON.parse(text);\n                                await this.import(process);\n                            } catch(error) {\n                                this.$emit('error', error, 'Paste Error');\n                            }\n                        }\n                        captured = true;\n                    }\n                    else if (event.code === 'KeyC') {\n                        if (!navigator || !navigator.clipboard || typeof navigator.clipboard.writeText !== 'function') {\n                            this.$emit('error', 'Copying is not supported by your browser.');\n                            return;\n                        }\n                        if (this.hasSelection) {\n                            this.clipboard = {\n                                blocks: this.selectedBlocks.slice(0),\n                                edges: this.selectedEdges.slice(0)\n                            };\n                        }\n                        else {\n                            try {\n                                let json = this.toJSON();\n                                await navigator.clipboard.writeText(json);\n                                captured = true;\n                            } catch(error) {\n                                this.$emit('error', error, 'Copy Error');\n                            }\n                        }\n                        captured = true;\n                    }\n                }\n            }\n\n            if (captured) {\n                event.preventDefault();\n                event.stopPropagation();\n            }\n        },\n        onMouseWheel(event) {\n            if (this.parameterViewer) {\n                return;\n            }\n            if (!this.explicitZoom || this.hasFocus || event.ctrlKey || event.metaKey) { // STRG for Win/Linux, meta/cmd for Mac\n                let mouse = this.getMousePos(event);\n                var dX = mouse[0] - this.state.center[0];\n                var dY = mouse[1] - this.state.center[1];\n                var deltaScale = Math.pow(1.1, Math.sign(event.deltaY)*-1);\n                this.moveCenter(-dX*(deltaScale-1), -dY*(deltaScale-1));\n                this.state.scale *= deltaScale;\n                event.preventDefault();\n                this.showZoomInfo = false;\n            }\n        },\n        domBoundingBox(el) {\n            var rect = el.getBoundingClientRect();\n            rect.offsetTop = rect.top + Math.max(document.documentElement.scrollTop, document.body.scrollTop);\n            rect.offsetLeft = rect.left + Math.max(document.documentElement.scrollLeft, document.body.scrollLeft);\n            return rect;\n        },\n        getMousePos(event) {\n            let root = this.$refs.div.getBoundingClientRect();\n            return [\n                event.clientX - root.left,\n                event.clientY - root.top\n            ];\n        },\n        onMouseMove(event) {\n            if (this.parameterViewer) {\n                return;\n            }\n            try {\n                let mousePos = this.getMousePos(event);\n\n                if (this.state.editable && this.selectedSideEdge) {\n                    var origin = this.selectedSideEdge.selectedParameter.getCirclePosition();\n                    if (origin) {\n                        var distance = Math.sqrt(Math.pow(mousePos[0]-origin[0], 2)+Math.pow(mousePos[1]-origin[1], 2));\n                        if (distance > 10) {\n                            this.link(this.selectedSideEdge.selectedParameter);\n                            this.removeEdge(this.selectedSideEdge);\n                            this.commit();\n                        }\n                    }\n                }\n\n                if (this.state.selecting) {\n                    this.state.selecting.current = mousePos;\n                }\n\n                if (this.state.moving) {\n                    this.moveCenter((mousePos[0]-this.state.moving[0]), (mousePos[1]-this.state.moving[1]));\n                    this.state.moving = mousePos;\n                }\n\n                if (this.state.linkFrom) {\n                    var position = this.state.linkFrom.getCirclePosition();\n                    if (position) {\n                        this.linkingLine = {\n                            x1: position[0],\n                            y1: position[1],\n                            x2: mousePos[0],\n                            y2: mousePos[1],\n                            'stroke': 'rgba(0,0,0,0.4)',\n                            'stroke-width': 3 * this.state.scale\n                        };\n                    }\n                }\n            } catch (error) {\n                this.$emit(\"error\", error);\n            }\n        },\n        onMouseDown(event) {\n            if (this.parameterViewer) {\n                return;\n            }\n            let sideSelected = null;\n            let mousePos = this.getMousePos(event);\n\n            if (event.which == 1) {\n                if (event.shiftKey) {\n                    // Start multi select via box\n                    this.state.selecting = {\n                        start: mousePos,\n                        current: mousePos\n                    }\n                }\n                else {\n                    // No multiselect: unselect all\n                    this.unselectAll();\n                }\n\n                // Select edges\n                for (var edge of this.edges) {\n                    if (!edge.$el) {\n                        continue;\n                    }\n                    var collide = edge.$el.collide(mousePos[0], mousePos[1]);\n                    if (collide != false) {\n                        if (this.selectedEdges.length === 0 && !event.shiftKey) {\n                            if (collide < 0.3) {\n                                sideSelected = edge.parameter2;\n                            }\n                            else if (collide > 0.7) {\n                                sideSelected = edge.parameter1;\n                            }\n                        }\n                        this.selectEdge(edge, true, sideSelected);\n                        if (edge.issues.length > 0) {\n                            for(let issue of edge.issues) {\n                                this.$emit('error', issue);\n                            }\n                        }\n                        event.preventDefault();\n                        break;\n                    }\n                }\n            }\n\n            if (event.which == 2 || (event.which == 1 && !sideSelected && !event.shiftKey)) {\n                this.state.moving = mousePos;\n            }\n\n            this.focus();\n        },\n\n        getDimensions() {\n            return this.domBoundingBox(this.$refs.div);\n        },\n\n        async clear() {\n            return await this.startTransaction(async () => {\n                this.edges = [];\n                // Don't remove parameters injected by props (fixed callback parameters)\n                this.blocks = this.blocks.filter(b => b.type === 'parameter' && Utils.isObject(b.spec) && b.origin === 'schema');\n                this.nextBlockId = 1;\n                this.nextEdgeId = 1;\n                this.process = {};\n                this.updateHiddenParameterRefEdges();\n                return true;\n            });\n        },\n\n        commit(data = null, history = true, propagate = true) {\n            // Don't commit when in a transaction\n            if (this.activeTransactions > 0) {\n                return;\n            }\n\n            if (history !== false) {\n                this.saveHistory();\n            }\n            if (propagate !== false) {\n                this.$emit('input', data === null ? this.export() : data);\n                this.updateHiddenParameterRefEdges();\n            }\n            else {\n                this.refreshEdges();\n            }\n        },\n    \n        /**\n         * Save the current situation to the history\n         */\n        saveHistory() {\n            var data = this.export(true);\n            this.history.splice(this.historyPointer + 1, this.historySize, Object.freeze(data));\n            if (this.history.length > this.historySize) {\n                this.history.shift();\n            }\n            this.historyPointer = this.history.length - 1;\n            this.$emit('historyChanged', this.history, this.historyPointer);\n        },\n        async undo() {\n            await this.historyStep(-1);\n        },\n        async redo() {\n            await this.historyStep(1);\n        },\n        async historyStep(step) {\n            var index = this.historyPointer + step;\n            var element = this.history[index];\n            if (element) {\n                this.historyPointer = index;\n                this.import(element, { saveHistory: false, undoOnError: false, perfectScale: false });\n                this.$emit('historyChanged', this.history, this.historyPointer);\n            }\n        },\n\n        setResultNode(block, result = true) {\n            block = this.getBlockById(block.id);\n            if (!block || block.result === result) {\n                return; // Nothing to change\n            }\n\n            this.updateBlockResult(block, result);\n            var foundNewResultNode = false;\n            var hasOtherBlocks = false;\n            for(var other of this.processBlocks) {\n                if (block && other.id === block.id) {\n                    continue;\n                }\n                \n                hasOtherBlocks = true;\n                // If we set a new result node, ensure that only that node is a result node and no other.\n                if (result) {\n                    this.updateBlockResult(other, false);\n                }\n                // Find a potential result node if we don't want this to be the result node\n                else {\n                    if (other.$el && !other.$el.hasOutputEdges()) {\n                        this.updateBlockResult(other, true);\n                        foundNewResultNode = true;\n                        break;\n                    }\n                }\n            }\n            // If we have no new potential result node, communicate to the user.\n            if (hasOtherBlocks && !result && !foundNewResultNode) {\n                this.$emit(\"error\", \"No result node available, please specify one.\");\n            }\n        },\n\n        getPositionForPageXY(x, y) {\n            var rect = this.getDimensions();\n            if (x !== null) {\n                x = (x - rect.offsetLeft - this.state.center[0]) / this.state.scale;\n            }\n            if (y !== null) {\n                y = (y - rect.offsetTop - this.state.center[1]) / this.state.scale;\n            }\n            return [x, y];\n        },\n\n        duplicate(data) {\n            data = Utils.deepClone(data);\n            if (data.position) {\n                data.position[1] += 100;\n            }\n            let block = this.addBlock(data);\n            this.$nextTick(() => this.createEdgesForArguments(block.id, data.arguments));\n        },\n\n        addProcess(process_id, args = {}, position = [], namespace = null) {\n            return this.addBlock({\n                process_id,\n                namespace,\n                arguments: args,\n                position\n            });\n        },\n\n        addBlock(node, id = null) {\n            let num = String(this.incrementId(id));\n            if (id === null && Utils.hasText(node.process_id)) {\n                id = node.process_id.replace(/^([a-z]*).*$/i, \"$1\") + num;\n                if (this.getBlockById('#' + id)) {\n                    id = num;\n                }\n            }\n            else {\n                id = num;\n            }\n            if (typeof node.toJSON === 'function') {\n                node = node.toJSON();\n            }\n            var block = {\n                id: '#' + id,\n                type: 'process',\n                selected: false,\n                position: node.position,\n                process_id: node.process_id,\n                namespace: node.namespace,\n                arguments: node.arguments,\n                description: node.description || null,\n                result: node.result || false\n            };\n            if (this.processRegistry) {\n                block.spec = this.processRegistry.get(node.process_id, node.namespace);\n            }\n\n            var size = this.getBlockSize(block);\n            block.position = Utils.ensurePoint(block.position, () => this.getNewBlockDefaultPosition(size));\n\n            // If there's already a result node, remove the flag here\n            if (block.result && this.blocks.filter(b => b.result === true).length) {\n                delete block.result;\n            }\n            // Make this the result node if there's no node yet\n            else if (this.processBlocks.length === 0) {\n                block.result = true;\n            }\n            \n            this.blocks.push(Vue.observable(block));\n            this.commit();\n            return block;\n        },\n\n        getNewBlockDefaultPosition(blockSize) {\n            var rect = this.getDimensions();\n            var position = [\n                (-this.state.center[0] + rect.width/2)/this.state.scale - blockSize[0]/2 + this.newBlockOffset,\n                (-this.state.center[1] + rect.height/2)/this.state.scale - blockSize[1]/2 + this.newBlockOffset\n            ];\n            if (this.newBlockOffset < 150) {\n                this.newBlockOffset += 10;\n            }\n            return position;\n        },\n\n        getBlockSize(block) {\n            if (block.$el) {\n                let dim = block.$el.getDimensions();\n                return [dim.width / this.state.scale, dim.height / this.state.scale];\n            }\n\n            let inputs = Math.max(\n                Utils.size(block.arguments),\n                Utils.isObject(block.spec) ? Utils.size(block.spec.parameters) : 0\n            );\n\n            let size = Config.blockWidth;\n            let width;\n            if (inputs > 0) {\n                width = this.state.compactMode ? size.compactParams : size.normalParams;\n            }\n            else {\n                width = this.state.compactMode ? size.compact : size.normal;\n            }\n\n            let commentHeight = typeof block.description === 'string' ? 40 : 0;\n            let height = MARGIN + inputs * 15 + commentHeight;\n\n            return [width, height];\n        },\n\n        moveCenter(dX, dY, reset = false) {\n            var rect = this.getDimensions();\n            this.state.center = [\n                (reset ? rect.width/2 : this.state.center[0]) + dX,\n                (reset ? rect.height/2 : this.state.center[1]) + dY\n            ];\n            this.newBlockOffset = 0;\n        },\n\n        unselectAll() {\n            for(var block of this.blocks) {\n                this.updateBlockSelected(block, false, false);\n            }\n            for(var edge of this.edges) {\n                this.selectEdge(edge, false);\n            }\n        },\n\n        selectEdge(edge, select = true, parameter = null) {\n            if (!Utils.isObject(edge)) {\n                edge = this.edges[edge];\n            }\n            if (edge.selected === select) {\n                return false; // Nothing to change\n            }\n            if (select !== null) {\n                this.$set(edge, \"selected\", select);\n            }\n            this.$set(edge, \"selectedParameter\", parameter);\n            return true;\n        },\n\n        /**\n         * Edge to remove\n         */\n        removeEdge(edge) {\n            edge.parameter1.eraseEdge(edge);\n            edge.parameter2.eraseEdge(edge);\n            this.$delete(this.edges, this.edges.indexOf(edge));\n        },\n            \n        /**\n         * Remove a block\n         */\n        async removeBlock(block) {\n            // Check if the parameter for this block is used in child processes (callbacks).\n            // Then don't delete, but give error instead.\n            if (block.type === 'parameter') {\n                let param = null;\n                let conflictBlock = this.blocks.find(otherBlock => {\n                    param = otherBlock.$el.hiddenParameterRef(block);\n                    return (param !== null);\n                });\n                if (conflictBlock) {\n                    throw new Error(`Parameter is still used in '${conflictBlock.id}', parameter '${param}'. Only unused parameters can be deleted.`);\n                }\n            }\n\n            // now start deleting the block\n            return await this.startTransaction(async () => {\n                var i = this.blocks.findIndex(b => b.id == block.id);\n                if (i < 0) {\n                    return false;\n                }\n\n                for (var edge of this.edges.slice(0)) {\n                    if (edge.parameter1.$parent.id === block.id || edge.parameter2.$parent.id === block.id) {\n                        this.removeEdge(edge);\n                    }\n                }\n\n                if (block.result) {\n                    this.setResultNode(block, false);\n                }\n\n                this.$delete(this.blocks, i);\n                return true;\n            });\n        },\n\n        /**\n         * Retreive a block by ID\n         */\n        getBlockById(blockId) {\n            var blocks = this.blocks.filter(block => block.id === blockId);\n            if (blocks.length > 0) {\n                return blocks[0];\n            }\n            return null;\n        },\n\n        /**\n         * Delete the current link\n         */\n        async deleteSelected() {\n            if (!this.hasSelection) {\n                return false;\n            }\n\n            return await this.startTransaction(async () => {\n                // Remove the selected blocks and its edges\n                for(var block of this.selectedBlocks.slice(0)) { // copy to avoid race condition\n                    if (block.$el.allowsDelete) {\n                        await this.removeBlock(block);\n                    }\n                }\n\n                // Removes the selected edges\n                for(var edge of this.selectedEdges.slice(0)) { // copy to avoid race condition\n                    this.removeEdge(edge);\n                }\n                return true;\n            });\n        },\n\n        async addEdgeByNames(b1, p1, b2, p2) {\n            var blocks = [];\n            for(var id of [b1, b2]) {\n                var block = this.getBlockById(id);\n                if (!block) {\n                    throw \"Can't find block: \" + id;\n                }\n                else if (!block.$el) {\n                    throw \"Block not mounted yet: \" + id;\n                }\n                blocks.push(block.$el);\n            }\n            await this.addEdge(\n                blocks[0].getBlockParameter(p1),\n                blocks[1].getBlockParameter(p2)\n            );\n        },\n \n        async addEdge(p1, p2) {\n            if (!p1 || !p2) {\n                throw 'One of the parameters is invalid.';\n            }\n            // Check whether you want to connect the same parameters\n            if (p1 == p2) {\n                return; // Probably by mistake, don't show an error to not annoy people\n            }\n            // Check whether you want to connect the block to itself\n            if (p1.$parent == p2.$parent) {\n                throw 'You can\\'t link a block to itself';\n            }\n\n            var id = this.nextEdgeId++;\n            var edge = {id, selected: false, inactive: false, issues: [], $el: null};\n            if (p1.output) {\n                edge.parameter1 = p1;\n                edge.parameter2 = p2;\n            }\n            else {\n                // Reverse the order of in and out\n                edge.parameter1 = p2;\n                edge.parameter2 = p1;\n            }\n\n            // You have to link an input with an output\n            if (edge.parameter1.output === edge.parameter2.output) {\n                throw 'You have to link an input with an output';\n            }\n            // Check for non-recursiveness\n            if (this.allSuccessors(edge.parameter1).indexOf(edge.parameter2.id) !== -1) {\n                throw 'You can not create a loop';\n            }\n            // Check whether the data type allows multiple input edges\n            if (edge.parameter2.getEdgeCount() > 0 && !edge.parameter2.allowsMultipleInputs) {\n                throw 'Parameter accepts only one input';\n            }\n\n            // Check whether the edge exists\n            for (var other of this.edges) {\n                if (other.$el && other.$el.equals(edge)) {\n                    throw 'This connection exists already';\n                }\n            }\n\n            // Check type compatibility\n            if (!JsonSchemaValidator.isSchemaCompatible(edge.parameter2.schema || {}, edge.parameter1.schema || {}, false, true)) {\n                let issue = 'Incoming data type is not compatible for parameter \"' + edge.parameter2.name + '\"';\n                edge.issues.push(issue);\n                this.$emit('error', issue);\n            }\n\n            return await this.startTransaction(async () => {\n                this.unlink();\n\n                // Create edge\n                this.edges.push(Vue.observable(edge));\n                edge.parameter1.addEdge(edge);\n                edge.parameter2.addEdge(edge);\n\n                // Update result node\n                this.setResultNode(edge.parameter1.$parent, false);\n                return true;\n            });\n        },\n\n        /**\n         * Find all successors of a block, and their successors\n         */\n        allSuccessors(outputParameter) {\n            var block = outputParameter.$parent;\n            // Blocks already explored\n            var explored = {};\n            var exploreList = [block];\n            explored[block.id] = true;\n        \n            while (exploreList.length > 0) {\n                var currentBlock = exploreList.pop();\n                for (var key in currentBlock.edges) {\n                    for (var i in currentBlock.edges[key]) {\n                        var edge = currentBlock.edges[key][i];\n                        if (edge.block1 == currentBlock) {\n                            var target = edge.block2;\n                            if (!(target.id in explored)) {\n                                explored[target.id] = true;\n                                exploreList.push(target);\n                            }\n                        }\n                    }\n                }\n            }\n\n            return Object.values(explored);\n        },\n\n        /**\n         * Changing the compact mode\n         */\n        async toggleCompact() {\n            this.state.compactMode = !this.state.compactMode;\n            this.$emit('compactMode', this.state.compactMode);\n            await this.$nextTick();\n            this.refreshEdges();\n        },\n\n        export(internal = false) {\n            let data = {\n                process_graph: {}\n            };\n\n            for(let block of this.processBlocks) {\n                let keys = ['process_id', 'namespace', 'arguments', 'description', 'result'];\n                if (internal) {\n                    // Keep internal state for history\n                    keys.push('position');\n                }\n                let copy = Utils.pickFromObject(block, keys);\n                // Remove default values for simplicity\n                if (copy.description === null) {\n                    delete copy.description;\n                }\n                if (copy.result !== true) {\n                    delete copy.result;\n                }\n                if (!copy.namespace) {\n                    delete copy.namespace;\n                }\n                let nodeId = block.id.substr(1);\n                data.process_graph[nodeId] = copy;\n            }\n\n            if (!this.parent) {\n                data.parameters = [];\n                let parameterBlocks = this.getPgParameters();\n                for(let param of parameterBlocks) {\n                    data.parameters.push(param.spec);\n                }\n            }\n\n            // ToDo: Currently, we just use the id, categories, result value etc from the original process.\n            // Implement to allow custom settings from users.\n            return new BlocksProcess(Object.assign({}, this.process, data));\n        },\n\n        // Options may contain:\n        // - undoOnError: don't undo changes when an error occured (default: true)\n        // - saveHistory: commit the changes to the history (default: true)\n        // - propagate: emit the changes to the parent v-model (default: true)\n        async startTransaction(fn, options = {}, ...args) {\n            let success;\n            this.activeTransactions++;\n\n            try {\n                success = await fn(args);\n            } catch (error) {\n                // If an error occured: show it and restore the last working state from history.\n                this.$emit('error', error, \"Model is invalid\");\n                if (options.undoOnError !== false) {\n                    try {\n                        await this.undo();\n                    } catch (error2) {\n                        this.$emit('error', error, \"Revert failed\");\n                    }\n                }\n                success = false;\n            }\n\n            this.activeTransactions--;\n            this.commit(null, options.saveHistory, options.propagate);\n\n            return success;\n        },\n\n        // Options may contain:\n        // - all from startTransaction()\n        // - clear: Clear the model builder before import (default: true)\n        // - perfectScale: Apply perfect scale after import (default: true)\n        async import(process, options = {}) {\n            return await this.startTransaction(async () => {\n                // clear screen...\n                if (options.clear !== false) {\n                    await this.clear();\n                    this.process = process instanceof ProcessGraph ? process.toJSON() : process;\n                }\n\n                if (!Utils.isObject(process)) {\n                    return false;\n                }\n\n                // Parse process\n                let pg;\n                if (process instanceof ProcessGraph) {\n                    // Make a copy\n                    pg = new ProcessGraph(process.toJSON(), this.processRegistry);\n                    pg.setParent(process.parentProcessId, process.parentParameterName);\n                }\n                else {\n                    pg = new ProcessGraph(process, this.processRegistry);\n                }\n                pg.allowEmpty();\n                pg.parse();\n                this.processGraph = Object.freeze(pg);\n\n                await this.importPgParameters(this.processGraph.getProcessParameters(true), 'user', options.clear !== false);\n                await this.importNodes(this.processGraph.getStartNodes());\n                await this.importEdges(this.processGraph);\n\n                if (options.perfectScale !== false) {\n                    this.perfectScale();\n                }\n\n                this.$nextTick(() => this.updateHiddenParameterRefEdges());\n\n                return true;\n            }, options);\n        },\n\n        async importPgParameters(params, origin, clear = true) {\n            if (!Array.isArray(params)) {\n                return;\n            }\n\n            let options = {\n                undoOnError: false,\n                saveHistory: false,\n                propagate: false\n            };\n            return await this.startTransaction(async () => {\n                // Remove existing parameters from the given origin\n                if (clear) {\n                    this.blocks = this.blocks.filter(b => b.type !== 'parameter' || b.origin !== origin);\n                }\n\n                let size = this.getBlockSize({}); // Estimate base size for an empty block\n                let position = [0,0];\n                for(var i in params) {\n                    position = [\n                        -size[0] - MARGIN,\n                        i * (size[1] + MARGIN)\n                    ];\n\n                    await this.addPgParameter(params[i], origin, position);\n                }\n            }, options);\n        },\n\n        async addPgParameter(param, origin = 'user', position = null) {\n            return await this.startTransaction(async () => {\n                let id = '$' + param.name;\n                // Check a parameter with the same name exists\n                if (this.blocks.findIndex(p => p.type === 'parameter' && p.id == id) >= 0) {\n                    return false;\n                }\n                param = Utils.deepClone(param);\n                if (typeof param.schema === 'undefined') {\n                    param.schema = {};\n                }\n                this.blocks.push(Vue.observable({\n                    id,\n                    type: 'parameter',\n                    origin,\n                    position: Utils.ensurePoint(position, () => this.getNewBlockDefaultPosition(this.getBlockSize({}))),\n                    spec: Object.freeze(param)\n                }));\n                return true;\n            });\n        },\n\n        getPgParameters() {\n            return this.blocks.filter(b => b.type === 'parameter');\n        },\n\n        getPgParameterById(id) {\n            return this.blocks.find(b => b.type === 'parameter' && b.id === id);\n        },\n\n        async importEdges(pg) {\n            var nodes = pg.getNodes();\n            return Promise.all(Object.values(nodes).map(node => this.importEdgesForNode(node)));\n        },\n\n        async importEdgesForNode(node) {\n            var args = node.getArgumentNames();\n            for(let i in args) {\n                let arg = args[i];\n                let val = node.getRawArgument(arg);\n                let ref = '#' + node.id;\n                switch(node.getArgumentType(arg)) {\n                    case 'result':\n                        await this.addEdgeByNames('#' + val.from_node, \"output\", ref, arg, false);\n                        break;\n                    case 'parameter':\n                        await this.addEdgeByNames('$' + val.from_parameter, \"output\", ref, arg, false);\n                        break;\n                    case 'object':\n                    case 'array':\n                        await this.importEdgeDeep(val, ref, arg);\n                        break;\n                }\n            }\n        },\n\n        async importEdgeDeep(val, nodeId, arg) {\n            for(let k in val) {\n                // k !== 'process_graph' prevents importing sub process graphs like in load_collection, see #118\n                if(val[k] && typeof val[k] === \"object\" && k !== 'process_graph') {\n                    await this.importEdgeDeep(val[k], nodeId, arg);\n                }\n                else if (!Utils.isRef(val)) {\n                    continue;\n                }\n                else if (val.from_node) {\n                    await this.addEdgeByNames('#' + val.from_node, \"output\", nodeId, arg, false);\n                }\n                else if (val.from_parameter) {\n                    await this.addEdgeByNames('$' + val.from_parameter, \"output\", nodeId, arg, false);\n                }\n            }\n        },\n\n        async createEdgesForArguments(nodeId, args) {\n            for(let arg in args) {\n                await this.importEdgeDeep(args[arg], nodeId, arg);\n            }\n        },\n\n        async importNodes(nodes, x = 0, y = 0, imported = []) {\n            let nextNodes = [];\n            let maxX = 0;\n            for(let node of nodes) {\n                // `node` is a Node class instance as defined by the js-processgraphs library\n                // `data` is the simple object that is defined by JSON process graphs\n                // `block` is the representation used by the Block component to render the block\n\n                // To get a better layout, only add the block once all previous nodes are added\n                if (imported.includes(node.id) || node.getPreviousNodes().find(prev => !imported.includes(prev.id)) !== undefined) {\n                    y += MARGIN / 2; // add a small offset so that lines going through a box are easier to see\n                    continue;\n                }\n\n                let data = typeof node.toJSON === 'function' ? node.toJSON() : node;\n                data.position = Utils.ensurePoint(data.position, () => [x,y]);\n\n                let block = this.addBlock(data, node.id);\n                imported.push(node.id);\n\n                let size = this.getBlockSize(block);\n                maxX = Math.max(maxX, data.position[0] + size[0]);\n                y = data.position[1] + size[1] + MARGIN;\n\n                nextNodes = nextNodes.concat(node.getNextNodes());\n            }\n            if (nextNodes.length) {\n                await this.importNodes(nextNodes, maxX + MARGIN, 0, imported);\n            }\n        },\n\n        incrementId(id = null) {\n            if (typeof id !== 'number' && (typeof id !== 'string' || id.length === 0)) {\n                id = this.nextBlockId;\n                this.nextBlockId++;\n            }\n            let int = Number.parseInt(id, 10);\n            if (!Number.isNaN(int)) {\n                this.nextBlockId = Math.max(this.nextBlockId, int+1);\n            }\n            return id;\n        },\n\n        /**\n         * Go to the perfect scale\n         */\n        perfectScale() {\n            if (!this.$refs.div || this.blocks.length === 0) {\n                return;\n            }\n\n            var xMin = null, xMax = null;\n            var yMin = null, yMax = null;\n\n            for (let block of this.blocks) {\n                let size = this.getBlockSize(block);\n                let pos = Utils.ensurePoint(block.position);\n                if (xMin == null) {\n                    xMin = pos[0]-15\n                    xMax = pos[0]+size[0]+15;\n                    yMin = pos[1]-15\n                    yMax = pos[1]+size[1]+15;\n                } else {\n                    xMin = Math.min(xMin, pos[0]-15);\n                    xMax = Math.max(xMax, pos[0]+size[0]+15);\n                    yMin = Math.min(yMin, pos[1]-15);\n                    yMax = Math.max(yMax, pos[1]+size[1]+15);\n                }\n            }\n\n            var rect = this.$refs.div.getBoundingClientRect();\n            var scaleA = rect.width/(xMax-xMin);\n            var scaleB = rect.height/(yMax-yMin);\n            this.state.scale = Math.min(scaleA, scaleB, 1.5); // Don't scale higher than 1.5\n            this.state.center = [\n                rect.width/2 - this.state.scale*(xMin+xMax)/2.0,\n                rect.height/2 - this.state.scale*(yMin+yMax)/2.0\n            ];\n            this.newBlockOffset = 0;\n        },\n\n        showParameterViewer(parameters, values, title, isEditable, selectParameterName, saveCallback, parent) {\n            this.parameterViewer = {\n                parameters,\n                values,\n                title,\n                selectParameterName,\n                parent\n            };\n        }\n    }\n};\n\nclass BlocksProcess {\n    constructor(process) {\n        Object.assign(this, process);\n    }\n}\n</script>\n\n<style lang=\"scss\">\n.vue-component.model-builder {\n\twidth: 100%;\n\theight: 100%;\n\tposition: relative;\n\n    &.editable.focus .blocks {\n        border-color: rgba(22, 102, 182, 0.3);\n    }\n\n    &:focus,\n    .blocks:focus,\n    .canvas:focus {\n        outline: 0;\n    }\n    \n    .canvas {\n        width: 100%;\n        height: 100%;\n        position: absolute;\n        z-index: 1;\n    }\n    \n    .blocks {\n        box-sizing: border-box;\n        border: 1px solid transparent;\n        overflow: hidden;\n        position: absolute;\n        z-index: 3;\n        width: 100%;\n        height: 100%;\n    }\n\n    &.compact .blockicon .delete,\n    &.compact .blockicon .info,\n    &.compact .blockicon .addDescription,\n    &.compact .blockId,\n    &.compact .editDescription, \n    &.scale_xs .blockicon,\n    &.scale_s .blockicon,\n    &.scale_xs .connector .text {\n        display: none;\n    }\n    .zoomInfo {\n        position: absolute;\n        top: 0;\n        right: 0;\n        display: inline-block;\n        padding: 0.3em;\n        background-color: #f9f9f9;\n        color: #000;\n        border-radius: 0 0 0 0.3em;\n        z-index: 5;\n    }\n    &.scale_xs .editDescription {\n        visibility: hidden;\n    }\n}\n</style>","import mod from \"-!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js??clonedRuleSet-82.use[1]!../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./ModelBuilder.vue?vue&type=script&lang=js&shadow\"; export default mod; export * from \"-!../node_modules/thread-loader/dist/cjs.js!../node_modules/babel-loader/lib/index.js??clonedRuleSet-82.use[1]!../node_modules/@vue/vue-loader-v15/lib/index.js??vue-loader-options!./ModelBuilder.vue?vue&type=script&lang=js&shadow\"","import { render, staticRenderFns } from \"./ModelBuilder.vue?vue&type=template&id=cfd84820&shadow\"\nimport script from \"./ModelBuilder.vue?vue&type=script&lang=js&shadow\"\nexport * from \"./ModelBuilder.vue?vue&type=script&lang=js&shadow\"\nfunction injectStyles (context) {\n  \n  var style0 = require(\"./ModelBuilder.vue?vue&type=style&index=0&id=cfd84820&prod&lang=scss&shadow\")\nif (style0.__inject__) style0.__inject__(context)\n\n}\n\n/* normalize component */\nimport normalizer from \"!../node_modules/@vue/vue-loader-v15/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  injectStyles,\n  null,\n  null\n  ,true\n)\n\nexport default component.exports","// Imports\nimport ___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___ from \"../node_modules/css-loader/dist/runtime/noSourceMaps.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_NO_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, `.vue-component.model-builder{width:100%;height:100%;position:relative}.vue-component.model-builder.editable.focus .blocks{border-color:#1666b64d}.vue-component.model-builder .blocks:focus,.vue-component.model-builder .canvas:focus,.vue-component.model-builder:focus{outline:0}.vue-component.model-builder .canvas{width:100%;height:100%;position:absolute;z-index:1}.vue-component.model-builder .blocks{box-sizing:border-box;border:1px solid #0000;overflow:hidden;position:absolute;z-index:3;width:100%;height:100%}.vue-component.model-builder.compact .blockId,.vue-component.model-builder.compact .blockicon .addDescription,.vue-component.model-builder.compact .blockicon .delete,.vue-component.model-builder.compact .blockicon .info,.vue-component.model-builder.compact .editDescription,.vue-component.model-builder.scale_s .blockicon,.vue-component.model-builder.scale_xs .blockicon,.vue-component.model-builder.scale_xs .connector .text{display:none}.vue-component.model-builder .zoomInfo{position:absolute;top:0;right:0;display:inline-block;padding:.3em;background-color:#f9f9f9;color:#000;border-radius:0 0 0 .3em;z-index:5}.vue-component.model-builder.scale_xs .editDescription{visibility:hidden}`, \"\"]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n"],"names":["content","__esModule","default","module","id","locals","exports","add","__inject__","shadowRoot","render","_vm","this","_c","_self","ref","class","classes","style","attrs","on","onMouseMove","onMouseDown","onMouseWheel","onKeyDown","$event","hasFocus","staticClass","_l","edges","edge","key","parameter1","parameter2","selected","inactive","issues","state","node","mount","unmounted","updateEdgePos","arguments","hiddenParameterRefEdges","linkingLine","_b","_e","selectRect","blocks","block","type","spec","position","origin","process_id","namespace","result","description","update","args","updateBlock","startDragBlock","scale","showZoomInfo","_v","parameterViewer","staticRenderFns","getDefaultState","Vue","observable","root","editable","compactMode","moving","selecting","center","mouse","Config","defaultScale","linkFrom","linkTo","MARGIN","selectionChangeWatcher","newVal","oldVal","Array","isArray","length","every","value","i","$emit","selectedBlocks","selectedEdges","name","components","Block","Edge","ParameterViewer","props","String","required","Boolean","Object","collections","processes","parent","parentSchema","historySize","Number","explicitZoom","height","data","isMounted","allMounted","newBlockOffset","history","historyPointer","process","freeze","processGraph","nextBlockId","nextEdgeId","clipboard","activeTransactions","computed","push","x","Math","min","current","start","y","width","abs","processRegistry","ProcessRegistry","count","get","Error","hasProcesses","processBlocks","filter","b","selectedSideEdge","selectedParameter","hasSelection","processParametersFromSchemas","parentParams","$parent","getPgParameters","map","callbackParams","getCallbackParameters","filteredParentParams","p1","find","p2","concat","watch","importPgParameters","BlocksProcess","import","propagate","undoOnError","immediate","handler","updateHiddenParameterRefEdges","checkAllMounted","beforeCreate","Utils","enableHtmlProps","created","supports","$on","msg","title","console","error","showParameterViewer","duplicate","bind","mounted","loadFontAwesome","moveCenter","onDocumentMouseUpFn","onDocumentMouseUp","document","addEventListener","perfectScale","beforeDestroy","removeEventListener","methods","pos","position1","position2","elem","$el","updateBlockArguments","removedParams","parameterRemoved","$set","commit","$nextTick","refreshEdges","updateBlockDescription","updateBlockPos","saveHistory","updateBlockResult","updateBlockSelected","unselectOthers","unselectAll","updateBlockSpec","parameterFields","newBlock","omitFromObject","assign","optional","deprecated","experimental","extra","setResultNode","hiddenRefs","argName","isObject","process_graph","refs","PgUtils","getRefs","from_parameter","isParameterScoped","parameter","getPgParameterById","getBlockParameter","warn","parameterNames","slice","includes","removeEdge","event","startDrag","refreshEdgesFor","values","updatePositions","$listeners","focus","$refs","div","link","unlink","multiSelect","box","getDimensions","boxIntersectsBox","e","boxIntersectsLine","toJSON","export","JSON","stringify","selectEdge","which","addEdge","allInputs","querySelectorAll","el","activeElement","captured","code","deleteSelected","ctrlKey","metaKey","navigator","readText","forEach","pickFromObject","text","parse","writeText","json","preventDefault","stopPropagation","getMousePos","dX","dY","deltaScale","pow","sign","deltaY","domBoundingBox","rect","getBoundingClientRect","offsetTop","top","max","documentElement","scrollTop","body","offsetLeft","left","scrollLeft","clientX","clientY","mousePos","getCirclePosition","distance","sqrt","x1","y1","x2","y2","sideSelected","shiftKey","collide","issue","clear","startTransaction","splice","shift","undo","historyStep","redo","step","index","element","getBlockById","foundNewResultNode","hasOtherBlocks","other","hasOutputEdges","getPositionForPageXY","deepClone","addBlock","createEdgesForArguments","addProcess","num","incrementId","hasText","replace","size","getBlockSize","ensurePoint","getNewBlockDefaultPosition","blockSize","dim","inputs","parameters","blockWidth","compactParams","normalParams","compact","normal","commentHeight","reset","select","eraseEdge","$delete","indexOf","removeBlock","param","conflictBlock","otherBlock","hiddenParameterRef","findIndex","blockId","allowsDelete","addEdgeByNames","b1","b2","output","allSuccessors","getEdgeCount","allowsMultipleInputs","equals","JsonSchemaValidator","isSchemaCompatible","schema","outputParameter","explored","exploreList","currentBlock","pop","block1","target","block2","toggleCompact","internal","keys","copy","nodeId","substr","parameterBlocks","fn","options","success","error2","ProcessGraph","pg","setParent","parentProcessId","parentParameterName","allowEmpty","getProcessParameters","importNodes","getStartNodes","importEdges","params","addPgParameter","p","nodes","getNodes","Promise","all","importEdgesForNode","getArgumentNames","arg","val","getRawArgument","getArgumentType","from_node","importEdgeDeep","k","isRef","imported","nextNodes","maxX","undefined","getPreviousNodes","prev","getNextNodes","int","parseInt","isNaN","xMin","xMax","yMin","yMax","scaleA","scaleB","isEditable","selectParameterName","saveCallback","constructor","injectStyles","context","style0","component","___CSS_LOADER_EXPORT___"],"ignoreList":[],"sourceRoot":""}